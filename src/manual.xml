<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>NSCLDAQ support for the CAEN VXxxxx series of digitizers with DPP-PHA.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>October 7, 2022</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
      <corpcredit>CAEN Technologies</corpcredit>
      <address><email>ron@caentechnologies.com</email></address>
    </bookinfo>
    <chapter id='ch.intro'>
        <title>Introduction</title>
        <para>
            This document describes how to configure and use the NSCLDAQ support
            for the new generation of CAEN VXxxxx digitizers.  I assume that:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  You have a basic familiarity with NSCLDAQ, how to configure it
                  and how to use its event builder.
               </para>
            </listitem>
            <listitem>
               <para>
                  You have a basic familiarity with how to use and tailor
                  the SpecTcl analysis package (if you choose to use this
                  for analysis).
               </para>
            </listitem>
            <listitem>
               <para>
                  You are familiar with the configuration parameters of the
                  DPP-PHA firmware supported by these modules.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that NSCLDAQ and SpecTcl documentation are all online at
            <ulink url='http://docs.nscl.msu.edu/daq' />.   Problems and questions
            about NSCLDAQ and SpecTcl (outside the scope of the CAEN Vxxxx digitizers)
            should be addressed to <ulink url='mailto:helpme@frib.msu.edu' />.
        </para>
        <para>
            The document is therefore organized into the following chapters:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  <link linkend='ch.readout' endterm='ch.readout.title'/> describes
                  how to create and configure a customized Readout program which
                  will inject data from a set of ADCs into the NSCLDAQ data flow
                  system.   Within that chapter,
                  <link linkend='sec.rdoprogramming' endterm='sec.rdoprogramming.title' />
                  describes the changes needed to the SBS readout skeleton.  The
                  format of events readout by this program will also be described.
                  <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />
                  describes how the modules are configured and how to write a
                  configuration file for your readout software.
               </para>
            </listitem>
            <listitem>
               <para>
                   <link linkend='ch.spectcl' endterm='ch.spectcl.title' />
                   describes how to build a tailored version of SpecTcl to produce
                   raw parameters from the modules  you are reading out. 
               </para>
            </listitem>
        </itemizedlist>
        <para>
            For those interested an appendix describes the structure of the software
            as well as items for further development.
        </para>
        <para>
            The <filename>tclreadout</filename> subdirectory of the source tree
            gives a sample tailored readout program for the readout software
            described in <link linkend='ch.readout' endterm='ch.readout.title' />.
            The <filename>tclreadout/SpecTcl</filename> subdirectory of the source
            tree gives a sample tailored SpecTcl program for this example.
        </para>
    </chapter>
    <chapter id='ch.readout'>
        <title id='ch.readout.title'>Getting Data</title>
        <para>
            Data is read from modules using a tailored SBS readout program that
            makes use of classes that have been written to support the new
            CAEN VXxxxx digitizers and DPP-PHA firmware.   These modules have
            a huge number of settable parameters.
        </para>
        <para>
            To manage the settable parameters, each module is associated with a
            <firstterm>configuration</firstterm>.  The module's configuration
            captures the desired settings for that module.  A module is assigned
            a name by your software and a matching named configuration is  read
            and used to configure that module at the start of each run.  The
            configuration is re-read each begin run so that changes can be made
            between runs.
        </para>
        <para>
            <link linkend='sec.rdoprogramming' endterm='sec.rdoprogramming.title' />
            describe how to tailor an SBS readout skeleton to produce a readout
            program.   <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />
            describes how to create module configurations and the parameters
            that can be set for a module.
        </para>
        <para>
            A few notes:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  While the software was developed with 12.0-pre, I believe the
                  support software will function with 11.3 as well.
               </para>
            </listitem>
            <listitem>
               <para>
                  Since each module is assigned a source id, when event building
                  the readout program should be run with the
                  <option>--no-barriers</option> optioon in order to prevent
                  the event builder from stalling on a barrier wait at the start
                  and end of runs.
               </para>
            </listitem>
        </itemizedlist>
        <section id='sec.rdoprogramming'>
            <title id='sec.rdoprogramming.title'>Obtaining and modifying the skeleton</title>
            <para>
                The Readout is based on the SBS readout skeleton.  This
                software allows for an experiment specific trigger which causes
                experiment specific code to be run.  SBS readout skeletons, therefore
                require tailoring to fit specific applications.

            </para>
            <para>
                Here are the steps required to tailor that system for the
                CAEN modules:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Select the version of NSCLDAQ you will use, and source in its
                      setup file to define environment variables that will make
                      your life easier.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Obtain a copy of the sbs skeleton in an emtpy directory. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Make appropriate modifications to the
                      <filename>Skeleton.cpp</filename>'s
                      <methodname>Skeleton::SetupReadout</methodname> method
                      to define the modules you will be using.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Modify the Makefile provided with the skeleton to pull in the
                      libraries and headers that make up support.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Build the Readout program. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Write a configuration file that appropriately configures
                      each module you defined (covered in
                      <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />).
                   </para>
                </listitem>
            </orderedlist>
            <para>
                The remainder of this section assumes you have selected
                NSCLDAQ-12.0-pre5.    To obtain that skeleton:
            </para>
            <example>
                <title>
                    Selecting DAQ version and obtaining the skeleton:
                </title>
                <programlisting>

source /usr/opt/daq/12.0-pre5/daqsetup.bash
mkdir myreadout
cd myreadout
cp $DAQROOT/skeletons/sbs/* .

                </programlisting>
            </example>
            <section>
                <title>Modifying the Skeleton</title>
                <para>
                    In this example, the key class is:
                    <classname>TclConfiguredReadout</classname> is a container
                    class that is an <firstterm>CEventSegement</firstterm> that
                    holds a set of modules to readout and constructs and appropriate
                    trigger to drive the readout.  It will also construct
                    and maintain objects for each module.
                </para>
                <para>
                    Construction specifies a configuration file that is processed
                    at the beginning of each run and used to program the
                    configuration of each module.
                </para>
                <para>
                    The class's <methodname>addModule</methodname> method
                    creates a module driver for a module, providing the connection
                    parameters for that module and associating it with a module
                    configuration within the configuration file. Each module,
                    so defined must be assigned a source id that is unique
                    across the system.  This source Id is used in event building.
                </para>
                <para>
                    Here are the parameter signatures for the methods you need
                    to use:
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>TclConfiguredReadout</methodname>
                            <methodparam>
                                <type>const char*</type><parameter>configfile</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CExperiment*</type><parameter>pExperiment</parameter>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>configfile</parameter> is the
                            path to a file that describes configurations for each
                            module that will be added to this event segment
                            (see <methodname>addModule</methodname>).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void</type>
                          <methodname>addModule</methodname>
                          <methodparam>
                              <type>const char*</type><parameter>name</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const char*</type><parameter>connectionString</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::uint32_t</type><parameter>sid</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool</type><parameter>isusb</parameter>
                              <initializer>false</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                                Adds a module to the readout.  <parameter>name</parameter>
                                is the name of a module in the configuration
                                file specified in the construtor.
                           </para>
                           <para>
                            <parameter>connectionString</parameter> is a string
                            that describes how the module is connected to the system.
                            This string is either a dotted IP address (e.g
                            "127.0.0.1") if ETHERNET is used or the PID of the module
                            if USB is used.  Note that DNS lookups are not done for
                            host names but there is nothing to stop you from doing
                            host lookups yourself prior to calling
                            <methodname>addModule</methodname>
                           </para>
                           <para>
                            <parameter>sid</parameter> is a unique integer source id
                            that identifies this module to the event builder.
                           </para>
                           <para>
                            <parameter>isUsb</parameter> is an optional parameter
                            that defaults to <literal>false</literal>.
                            If <literal>true</literal>, it specifies that the
                            <parameter>connectionString</parameter> is a module PID
                            and that the connection is via USB.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>CTrigger*</type>
                          <methodname>getTrigger</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the trigger that the object
                            has computed for the modules that have been added to it.
                            This should be used to supply a trigger object to the
                            Readout program framework.
                           </para>
                        </listitem>
                    </varlistentry>

                </variablelist>
                                <para>
                    Let's look at a simple example.  The full example is in
                    the <filename>tclreadout</filename> subdirectory of the
                    source tree.  If you want to use that as a starting point,
                    simply modify the <literal>INSTDIR</literal> definition
                    at the top of the file to point to the version of NSCLDAQ
                    you decided to use.
                </para>
                <example id='ex.skeleton'>
                    <title id='ex.skeleton.title'>Sample Skeleton.cpp modifications</title>
                    <programlisting>
#include &lt;config.h&gt;
#include &lt;Skeleton.h&gt;
#include &lt;CExperiment.h&gt;
#include &lt;TCLInterpreter.h&gt;
#include &lt;CTimedTrigger.h&gt;
#include &lt;TclConfiguredReadout.h&gt;   <co id='rdo.classinc' />
#include &lt;Dig2Device.h&gt;             <co id='rdo.tracinginc' />

...

void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
 
  CReadoutMain::SetupReadout(pExperiment);
  
  // turns on felib tracing if compiled with it enabled

  // caen_nscldaq::set_tracing(true);    <co id='rdo.tracing' />
  
  // First we create a TclConfiguredReadout object and describe the
  // connections to the modules in the system -- assigning each
  // module a distinct source id for event building.
  // Note that the event builder allows fragments from the same source to get
  // grouped into the same event and each fragment is tagged with its channel..
  // so per-module sids rather than per-channel work just fine:
  
  auto pSegment = new TclConfiguredReadout(   <co id='rdo.makesegment'/>
    "configuration.tcl",            // Detailed module settings file path.
    pExperiment                     // Pointer to experiment object.
  );
  pSegment-&gt;addModule(                    <co id='rdo.addmodule' />
    "adc1",                   // Name of module in configuration.tcl
    "15236",                   // PID for USB connection, IP If ethernet.
    1,                        // System unique source id.
    true                      // Indicates it's USB not Ethernet defaults to false.
  );
  
  pExperiment-&gt;AddEventSegment(pSegment);   <co id='rdo.registersegment' />
  
  // The event segment creates a dynamic multi trigger object which we need
  // to fetch out and register as the trigger for the system:
  
  pExperiment-&gt;EstablishTrigger(pSegment->getTrigger()); <co id='rdo.registertrigger' />
  
}


                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='rdo.classinc' >
                        <para>
                            This <literal>#include</literal> is needed to define
                            the <classname>TclConfiguredReadout</classname>
                            class.
                        </para>
                    </callout>
                    <callout arearefs='rdo.tracinginc' >
                        <para>
                            Wrappers for the CAEN libraries support tracing the
                            operations and responses performed on the module.
                            This header provides definitions needed to enable
                            this tracing.  Note that tracing must be enabled both
                            programmatically and via a compilation option in the
                            library Makefile.
                        </para>
                    </callout>
                    <callout arearefs='rdo.tracing' >
                        <para>
                            If the library has been built with tracing enabled,
                            uncommenting this line will turn that on. Note that this
                            will create a large trace file, as well as adversely
                            impact performance.
                        </para>
                    </callout>
                    <callout arearefs='rdo.makesegment' >
                        <para>
                            Creates the <classname>TclConfiguredReadout</classname>
                            object that will manage the modules we will use.
                            At the start of each run, <filename>configuration.tcl</filename>
                            will be processed to load the configuration for each
                            module and each module will then be asked to configure itself
                            in accordance with its configuration.  The
                            <parameter>pExperiment</parameter> pointer passed in
                            to <methodname>SetupReadout</methodname> points to
                            an object that provides services needed.
                        </para>
                        <para>
                            Note that <methodname>SetupReadout</methodname> is only
                            called once at system startup and the lifetime of the
                            <classname>TclConfiguredReadout</classname> will be
                            the lifetime of the Readout program.  Therefore,
                            the fact that the <varname>pSegment</varname>
                            never is deleted is not a memory leak.
                        </para>
                    </callout>
                    <callout arearefs='rdo.addmodule' >
                        <para>
                            Adds a module to the system.  The module is named
                            <literal>adc1</literal> and will, therefore expect
                            a configuration for <literal>adc1</literal>.
                            It is a USB connected module with PID 
                            <literal>15236</literal> and is assigned source id
                            <literal>1</literal>.
                        </para>
                        <para>
                            The <classname>TclConfiguredReadout</classname>
                            will manage this module from now on.  It will also
                            produce a part of the readout trigger based
                            on data being available in this module.
                        </para>
                    </callout>
                    <callout arearefs='rdo.registersegment' >
                        <para>
                            The <classname>TclConfiguredReadout</classname>
                            event segment is registered with the experiment framework
                            so that its methods will be invoked by that framework
                            when appropriate.
                        </para>
                    </callout>
                    <callout arearefs='rdo.registertrigger' >
                        <para>
                            The trigger computed by the
                            <classname>TclConfiguredReadout</classname> event
                            segment is fetched and established as the trigger
                            for readout.  When a run is active this trigger is
                            polled and, when it indicates that it has been
                            triggered, readout will ensue.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Modifying the Makefile and Building Readout</title>
                <para>
                    The CAEN digitizer support software (NSCLDAQ and base).  The
                    SBS skeleton readout Makefile must be edited to ensure that
                    appropriate include directories are searched when compiling
                    and libraries pulled in when linked:
                </para>
                <itemizedlist>
                    <listitem>
                       <para>
                          <literal>-lCAEN_FELib</literal>  must be added
                          to the definition of <varname>USERLDFLAGS</varname>
                          This links in the base CAEN library that provides
                          support for communicating with the digitizer.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          JavaScript Object Notation (JSON) is used to specify readout formats and a JSON
                          support library (JSONCPP) is used to format those requests.
                          This is a package that's installed in the containers
                          we distribute or, if you are running native, is a
                          debian package: <literal>libjsoncpp-dev</literal>
                          Due to headers that are included by other headers,
                          <literal>$(shell pkg-config jsoncpp --cflags)(</literal>
                          must be added to <varname>USERCCFLAGS</varname>
                          and <literal> $(shell pkg-config jsoncpp  --libs)</literal>
                          added to <varname>USERLDFLAGS</varname>
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Tracing FE library calls is done via the boost logging
                          package so
                          <literal>-lboost_log -lboost_log_setup  -lboost_thread -lboost_syste</literal>
                          must be added to <varname>USERLDFLAGS</varname>.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                           Finally we need to pull in the NSCLDAQ support
                           library.  Suppose the headers are all installed in
                           <literal>$(CAEN_NSCLDAQ)/include</literal> and
                           libraries in <literal>$(CAEN_NSCLDAQ)/lib</literal>.
                           <literal>-I$(CAEN_NSCLDAQ)/include</literal>
                           must be added to <varname>USERCCFAGS</varname> and
                           <literal>-L$(CAEN_NSCLDAQ)/lib -lCaenVx2750</literal>
                           to <varname>USERLDFLAGS</varname>
                       </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Once this has been done, the Readout program can be built
                    via <command>make</command>
                </para>
            </section>
        </section>
        <section id='sec.rdoconfig'>
            <title id='sec.rdoconfig.title'>Configuring modules</title>
            <para>
                Each module must be configured to be useful.  This is done by
                writing a configuration script.  Configuration scripts are
                written in a domain specific language layered on top of the
                Tcl scripting language.  Tcl is extended by adding a single command
                ensemble: <command>v27xxpha</command> to Tcl. 
            </para>
            <para>
                A command ensemble in Tcl parlance is a single command that has
                subcommands specified by the next word on the command line.  The
                <command>v27xxpha</command> command has the following forms:
            </para>
            <variablelist>
                <varlistentry>
                   <term><command>vx27xxpha create <replaceable>module-name</replaceable></command></term>
                   <listitem>
                       <para>
                        Creates a new configuration for a module <parameter>module-name</parameter>.
                        When the Readout initializes modules it looks for configurations
                        that match the names of modules that have been added
                        to the <classname>TclConfiguredReadout</classname>
                        module.
                       </para>
                       <para>
                        thus in our example
                        <link linkend='ex.skeleton' endterm='ex.skeleton.title' />
                         <command>vx27xxpha create adc1</command> would create
                         a configuration for the module we added.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha config <replaceable>module-name name value ...</replaceable></command></term>
                   <listitem>
                       <para>
                        Configures one or more parameter values for the
                        <parameter>module-name</parameter>.  Any number of
                        parameter name/value pairs can be specified on the command.
                        For example:
                        <command>v27xxpha config adc1 dcoffsets [lrepeat 64 0]</command>
                        Configures the DC offsets for all 64 channels to be 0% of
                        full scale.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha cget <replaceable>module-name name</replaceable></command></term>
                   <listitem>
                       <para>
                        This command returns the value of the parameter
                        <parameter>name</parameter> from the configuration
                        for the module <parameter>module-name</parameter>.
                        For example:
                        <command>puts [vx27xxpha cget adc1 dcoffsets]</command>
                        will print 64 zeroes to stdout.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha delete <replaceable>module-name</replaceable></command></term>
                   <listitem>
                       <para>
                        Really not necessary - this deletes the configuration
                        for <parameter>module-name</parameter>.  Since the
                        configuration file is processed and all configuration rebuilt
                        from scratch at each begin run,
                        there's really no need to delete modules.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx25x0 list</command></term>
                   <listitem>
                       <para>
                        Returns a list of the module names that have configurations.
                        the following little script will list the modules
                        configured, one per line to stdout:
                       </para>
                       <informalexample>
                        <programlisting>
foreach module [vx27xxpha list] {
    puts $module
}
                        </programlisting>
                       </informalexample>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                A sample configuration file that goes along with the
                sample readout program in the <filename>tclreadout</filename>
                subdirectory of the source tree is 
                <filename>/configuration.tcl</filename>.
            </para>
            <section>
                <title>Configuration parameter reference</title>
                <para>
                    This section consists of several subsections.  Each
                    subsection provides a reference for a set of configuration
                    parameters that are related in some way.
                    Parameters are describes as follows:
                </para>
                <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem><seg>Name of the parameter</seg>
                    <seg>Data type the item must be</seg>
                    <seg>Defeault value for the item</seg>
                    <seg>Description of the item.</seg>
                    </seglistitem>
                </segmentedlist>
                <para>
                    A note on the boolean data type.  Any of the following are
                    valid true values:
                    <literal>true, yes, 1, on, enabled</literal>, while any
                    of the following are valid false value
                    <literal>false, no, 0, off, disabled</literal>.
                </para>
                <para>
                    A note on integer data types.  These can be expressed in base
                    10, 16 or 8. Base 16 values should be prefixed by 0x,
                    e.g. <literal>0x5a5a5a5a5a5a5a5a</literal>.  Base 8 values
                    are prefixed by a leading zero e.g. 0777.
                    
                </para>
                <warning>
                    <title>WARNING</title>
                    <para>
                        Do not use leading zeros to align decimal values,
                        they will be treated as octal and, in general,
                        not have the intended effect.  This is a curse that has
                        afflicted many a user of the Tcl language.
                    </para>
                </warning>
                <para>
                    When in doubt about the meaning of a parameter see CAEN
                    document
                    <literal>UM7788 --FELib PHA Parameters User Manual</literal>.
                </para>
                <section>
                    <title>Readout Options</title>
                    <para>
                        The parameters in this section are not actually digitizer
                        parameters, the determine what is read from the
                        digitizer at each event.  All events will read the
                        event channel number, timestamp in nanosecods
                        and energy from the DPP-PHA.
                        These options allow additional available parameters/features
                        to be read from the digitizer.
                    </para>
                    <para>
                        The configuration parameters are:
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>readrawtimes</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the raw time stamp counter is included
                        in each event.  Note that the nanosecond timestamp
                        is always used for even building as the raw timestamp
                        may vary in frequency depending on the digitizer.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readfinetimestamps</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, and if the module supports the generation
                        of fine timing information (e.g. interpolated timing from
                        a CFD), turning this on enables the inclusion of that fine
                        timing information in the event.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readflags</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled reads various bits that report on the
                        digitizer's state</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readtimedownsampling</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, reads a code that corresponds to the
                        digitizer sampling scaledown</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readanalogprobes</seg>
                        <seg>list of two booleans</seg>
                        <seg>{false false}</seg>
                        <seg>The module supports two analog probes these can be used
                        to acquire the input waveforms as well as various diagnostic
                        information.  The first element of the list enables/disables
                        the inclusion of analog probe1 and the second the inclusion of
                        analog probe 2</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readdigitalprobes</seg>
                        <seg>list of four booleans</seg>
                        <seg>{false false false false}</seg>
                        <seg>The digitizer supports the inclusion of four digital probes.
                        A digital probe has a byte per sample with a value of 0 or
                        1.  The list can selectively enable the inclusion of data
                        from each probe.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readsamplecount</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the number of samples read for this
                        channel are included.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readeventsize</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the raw event size is read.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>General options</title>
                    <para>
                        These parameters control general module wide functionality.
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>clocksource</seg>
                        <seg>Enumerated</seg>
                        <seg><literal>Internal</literal></seg>
                        <seg>Selects the source of the digitizer's clock.
                        Valid values are <literal>Internal</literal>
                        to use the module's internal clock or
                        <literal>FPClkIn</literal> to use the front panel clock
                         input.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>outputfpclock</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If <literal>true</literal>, the digitizer clock is output
                        on the front panel.  This allows modules to use a single
                        shared clock source without needed an external clock.
                        Clock delays can then compensate for clock propagation
                        delays as one progresses  down the clock in/clock out
                        daisy chain.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Triggerring and I/O</title>
                    <para>
                        The parameters control digitizer and channel level triggers
                        as well as the LEMO connectors on the front panel.
                    </para>
                    <segmentedlist>
                    <title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>startsource</seg>
                        <seg>List of enumerated values</seg>
                        <seg>SWcmd</seg>
                        <seg>The list of ways the digitizer can start a run.
                        The digitzer is started on the or of the conditions
                        in the list.  Usually, in a synchronized set, the
                        'master' digitizer is stated on <literal>SWcmd</literal> and the others
                        on e.g. <literal>SINedge</literal>.   Valid values for list elements are:
                        <literal>EncodedClkIn, SINlevel, SINedge, SWcmd, LVDS, P0</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>gbltriggrsrc</seg>
                        <seg>List of Enums</seg>
                        <seg>TrgIn</seg>
                        <seg>The sources of the module global trigger.  The
                        or of the values listed makes a global trigger.
                        Valid values are
                        <literal>TrgIn, P0, SwTrg, LVDS, ITLA, ITLB,
                        ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn, GPIO,
                        TestPulse</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>wavetriggersrc</seg>
                        <seg>List of 64 lists of enums</seg>
                        <seg>[lrepeat TRGIN 64]</seg>
                        <seg>This parameter is a list of 64 trigger sources for
                        wave acquisition.  Each element of that list is itself
                        a list of triggers sources for that channel.  Valid
                        values for the trigger sources are:
                        <literal>
                            ITLB, ITLA, GlobalTriggerSource, TRGIN, ExternalInhibit,
                            ADCUnderSaturation, ADCOverSaturation, SWTrg, ChSelfTrigger,
                            Ch64Trigger, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>eventtriggersrc</seg>
                        <seg>List of 64 lists of enums</seg>
                        <seg>[lrepeat TRGIN 64]</seg>
                        <seg>Similar to the <literal>wavetriggersrc</literal>
                        but provides, for each channel a list of event trigger
                        sources.   Valid values are:
                        <literal>
                            ITLB, ITLA, GlobalTriggerSource, TRGIN, SWTrg, ChSelfTrigger,
                            Ch64Trigger, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>channeltriggermasks</seg>
                        <seg>List of 64 uint64_t</seg>
                        <seg>[lrepeat 0 64]</seg>
                        <seg>In <literal>Ch64Trigger</literal> mode, or coincidence
                        triggering mode, used to define the set of channels that
                        particpate in triggering each channel.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>savetraces</seg>
                        <seg>List of 64 enums</seg>
                        <seg>[lrepeat OnRequest 64]</seg>
                        <seg>Determines when wave traces are saved for each
                        channel.  Valid values are
                        <literal>Always, OnRequest</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>triggeroutmode</seg>
                        <seg>Enumerated value</seg>
                        <seg>TRGIN</seg>
                        <seg>Determines what is output on the <literal>TRGOUT</literal>
                        LEMO output.  Valid values are:
                        <literal>
                            TRGIN, P0, SwTrg, LVDS, ITLA, ITLB,
                            ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn,
                            Run, RefClk, TestPulse,
                            Busy, Fixed0, Fixed1, SyncIn, SIN, GPIO,
                            AcceptTrg, TrgClk
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>gpiomode</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>Selects the signal to output on the
                        GIO LEMO connector.
                        This can be one of
                        <literal>
                            Disabled, TrgIn, P0, SIN, LVDS, ITLA, ITLB,
                            ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn, SwTrg,
                            Run, RefClk, TestPulse, Busy, Fixed0, Fixed1
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>busyinsrc</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>Determines the source of the external
                        module busy input.  This is one of:
                        <literal>SIN, GPIO, LVDS, Disabled</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>syncoutmode</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>
                            Determines the source of the <literal>SOUT</literal>
                            LEMO connector.  Valid values are
                            <literal>
                                Disabled, SyncIn, TestPulse, IntClk, Run
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetosrc</seg>
                        <seg>Enumerated value</seg>
                        <seg>Source of the board level trigger veto. Valid values are
                        <literal>
                            SIN, LVDS, GPIO, P0, EncodedClkIn, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetowidth</seg>
                        <seg>Integer nano-seconds 0 - 34359738360</seg>
                        <seg>200</seg>
                        <seg>Ns stretch applied to the board veto source</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetopolarity</seg>
                        <seg>Enumerated value</seg>
                        <seg>ActiveLow</seg>
                        <seg>
                            Polarity of the veto input.  One of
                            <literal>ActiveHigh, ActiveLow</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetosrc</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Disabled 64]</seg>
                        <seg>Veto sources for each of the channels.  Each list element
                        can have one of the value:
                        <literal>
                            BoardVeto, ADCOverSaturation, ADCUnderSaturation, Disabled
                        </literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetowidth</seg>
                        <seg>List of 64 integer in units of ns 0-524280</seg>
                        <seg>[list 200 64]</seg>
                        <seg>The stretch applied to each channel's veto source.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>rundelay</seg>
                        <seg>Integer nanoseconds 0-54280</seg>
                        <seg>0</seg>
                        <seg>
                            This value is used to fine tune the synchronized
                            start of multi-board data taking. When the start source
                            is true, the actual start will be delayed by the ns
                            set in this parameter.  If, for example, the start is
                            propagated via a SIN/SOUT daisy chain on the front panel, the
                            final board will be delayed by 0 ns, the next to last
                            board by the single board propagation delay and so on.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetowidth</seg>
                        <seg>boolean</seg>
                        <seg>true</seg>
                        <seg>When true, the module is disarmed when data taking is
                        stopped.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>volclkoutdelay</seg>
                        <seg>Floating point ps -18888.8888 - 18888.8888</seg>
                        <seg>0.0</seg>
                        <seg>
                            Sets the value that is programmed into the clock PLL
                            delay.  This is used to synchronize clocks passed between
                            boards via the CLKOUT/CLKIN daisy chain.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>permclkoutdelay</seg>
                        <seg>volclkoutdelay</seg>
                        <seg>Floating point ps -18888.8888 - 18888.8888</seg>
                        <seg>0.0</seg>
                        <seg>
                            Sets the value that is programmed into the clock PLL
                            delay on power up.  This is used to synchronize clocks passed between
                            boards via the CLKOUT/CLKIN daisy chain.  Note that
                            this value is first programmed and then the volclkoutdelay
                            which actually controls the clock delay.
                            In a future bit of development a parameter migth be
                            added to select which of these two values controls
                            the actual clock delay.
                        </seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Wave form inspection and digital probes.</title>
                    <para>
                        Note that whlie the waveform and digital probe values are
                        programmed here, in order to actually include those
                        probes in the data read from the digitizer,
                        <literal>readanalogprobes</literal> and/or
                        <literal>readdigitalprobes</literal> must be set
                        accordingly.
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>wavesource</seg>
                        <seg>List of enumerated values</seg>
                        <seg>[lrepeat ADC_DATA 64]</seg>
                        <seg>
                            This is a list of one entry per channel that describes
                            what the FADC for that channel sees on its input.
                            Valid values are:
                            <literal>
                                ADC_DATA, ADC_TEST_TOGGLE, ADC_TEST_RAMP,
                                ADC_TEST_SIN, IPE,
                                 Ramp, SquareWave, ADC_TEST_PRBS
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>recordsamples</seg>
                        <seg>List of 64 integers 4-8100</seg>
                        <seg>[lrepeat 4 64]</seg>
                        <seg>Each element determines the number of samples that
                        channel of the ADC will process/record.  The actual time
                        represented depends on the value of the <literal>saveresolutions</literal>
                        parameter for that channel.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>waveresolutions</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Res8 64]</seg>
                        <seg>For each channel, selects the sampling resolution in
                        nanoseconds.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>analogprobe1, analogprobe2</seg>
                        <seg>List of 64 enumerated values</seg>
                        <seg>[lrepeat ADCInput 64], [lrepeat TimeFilter 64]</seg>
                        <seg>
                            For each channel, the analog probes available
                            for acquisition from that channel.   Allowed values
                            are:
                            <literal>
                                ADCInput, TimeFilter, EnergyFilter,
                                EnergyFilterBaseline,
                                EnergyFilterMinusBaseline
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>digitalprobe1, digitalprobe2, digitalprobe3, digitalprobe4</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Trigger 64], [lrepeat TimeFilterArmed 64],
                        [lrepeat RetriggerGuard 64],
                        [lrepeat EneryFilterBaselineFreeze 64]</seg>
                        <seg>
                            For each channel, the digital probes available for
                            acquisition from that channel.  Valid values are:
                            <literal>
                                Trigger, TimeFilterArmed, ReTriggerGuard,
                                EnergyFilterBaselineFreeze,
                                EnergyFilterPeaking, EnergyFilterPeakReady,
                                EnergyFilterPileUpGuard, EventPileup, ADCSaturation,
                                ADCSaturationProtection, PostSaturationEvent,
                                EnergyFilterSaturation,
                                AcquisitionInhibit
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>pretriggersamples</seg>
                        <seg>List of 64 integers 4-4000</seg>
                        <seg>[lrepeat 100 64]</seg>
                        <seg>For each channel, the number of samples
                        prior to the trigger that will be acquired and
                        analyzed by the DPP-PHA firmware.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Service options</title>
                    <para>
                        These, for the most part, have to do with the test pulser.
                        There are also miscellaneous parameters to control
                        error handling and the LEMO I/O levels.
                    </para>
                    <segmentedlist>
                        <title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>testpulserperiod</seg>
                        <seg>Integer ns 0-34359738360</seg>
                        <seg>100000</seg>
                        <seg>The period of the test puler in ns.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulsewidth</seg>
                        <seg>Integer ns 0-34359738360</seg>
                        <seg>1000</seg>
                        <seg>Width of the high part of the test pulser
                        period.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulselowlevel</seg>
                        <seg>Integer 0-65535</seg>
                        <seg>0</seg>
                        <seg>The low level output of the pulser</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulsehighlevel</seg>
                        <seg> Integer 0-65535</seg>
                        <seg>65535</seg>
                        <seg>The high level output of the pulser</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>iolevel</seg>
                        <seg>Enumerated value</seg>
                        <seg>NIM</seg>
                        <seg>The signalling level to be used by the
                        LEMO I/O connectors.  This can be one of
                        <literal>NIM</literal> or <literal>TTL</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>errorflagmask</seg>
                        <seg>Integer 0-0xffff</seg>
                        <seg>0</seg>
                        <seg>Error flag bitmask that determines what lights
                        the front panel error LED given specific error
                        conditions</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>errorflagdatamask</seg>
                        <seg>Integer  0-0xffff</seg>
                        <seg>0</seg>
                        <seg>Error flag bitmask that determines which which error
                        conditions result in an error condition in the event.</seg>
                    </seglistitem>
                    </segmentedlist>
                    
                </section>
                <section>
                    <title>Internal Logic block parameters</title>
                    <para>
                        Triggers can be the result of sophisiticated conditions in
                        two internal logic blocks called ITLA and ITLB.
                        This set of parameters determine how those  logic blocks
                        function.  Because there are two logic blocks, These
                        parameters are  mostly in pairs, on parameter for ITLA
                        and a second for ITLB
                    </para>
                    <segmentedlist>
                        <title>
                        </title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>itlalogic, itlblogic</seg>
                        <seg>Enumerated value</seg>
                        <seg>OR, OR</seg>
                        <seg>
                            Determines how the channel inputs to the
                            ITLA/ITLB logic blocks are interpreted to
                            create a trigger output from that block.
                            Options are:
                            <literal>
                              OR, AND, Majority
                            </literal>
                            Note that if <literal>Majority</literal>  is selected,
                            <literal>itlxmarjoritylevel</literal> determines the
                            actual majoriy level required.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlamajoritylevel, itlbmajoritylevel</seg>
                        <seg>Integeer 1-63</seg>
                        <seg>1</seg>
                        <seg>The majority level for the specified trigger
                        gropu.  Note this is only relevant if the corresponding
                        trigger block is functioning in <literal>Majority</literal>
                        mode.</seg>
                        
                    </seglistitem>
                    <seglistitem>
                        <seg>itlapairlogic, itlbparilogic</seg>
                        <seg>Enumerated value</seg>
                        <seg>None, None</seg>
                        <seg>
                            Adjacent channel pairs (0,1 2,3 etc.) can be combined
                            as inputs to the ITLA or ITLB logic blocks. These
                            parameters determine if and how those pairs are combined.
                            When combined, both outputs of the pair will be the
                            ouptput of the logic function applied (e.g. if in AND
                            mode and only channel 0 triggers, then both inputs 0 and 1
                            will be in the untriggered state as inputs to the logic block).
                            Possible values are:
                            <literal>
                                AND, OR, NONE
                            </literal>  Where <literal>AND</literal> as well as
                            <literal>OR</literal> combine the inputs into a paired
                            while <literal>NONE</literal> passes the inputs to their
                            corresonding outputs without any pair logic.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlapolarity, itlbpolarity</seg>
                        <seg>Enumerated value</seg>
                        <seg>Direct, Direct</seg>
                        <seg>Determines the output polarity of the specified
                        trigger logic block.
                        This can be either <literal>Direct</literal>
                        or <literal>Inverted</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlamask, itlbmask</seg>
                        <seg>Integer 0 - 0xffffffffffffffff</seg>
                        <seg>0xffffffffffffffff, 0xffffffffffffffff</seg>
                        <seg>This mask has a bit for each channel, if set that channel
                        participates in the associated internal trigger logic block.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlagatewidth, itlbgatewidth</seg>
                        <seg>Integer nanoseconds 0-524280</seg>
                        <seg>100, 100</seg>
                        <seg>The ITLA and ITLB outputs are inputs to gate generators.
                        These parameters determine the width of the output of that
                        gate generator in ns.</seg>
                    </seglistitem>
                    </segmentedlist>
                    
                </section>
                <section>
                    <title>LVDS Options</title>
                    <para>
                        The 16 LVDS I/Os can be programmed in a sets of four (quartets).
                        The parameters in this section describe how to configure them.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>lvdsmode</seg>
                            <seg>List of 4 enumerated values</seg>
                            <seg>[lrepeat IORegister 4]</seg>
                            <seg>
                                Determines the functionality of each of the four
                                quartets of LVDS I/Os:
                                <literal>SelfTriggers, Sync, IORegister</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdsdirection</seg>
                            <seg>List of four enumerate valus</seg>
                            <seg>[lrepeat Output 4]</seg>
                            <seg>Determines the direction of each of the four
                            quartests of LVDS I/Os: <literal>Input, Output</literal></seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdstrgmask</seg>
                            <seg>List of 16 integer values 0 - 0xffffffffffffffff</seg>
                            <seg>[lrepeate 0 16]</seg>
                            <seg>If a quartet is in <literal>SelfTriggers</literal>
                            mode as an <literal>Output</literal>, these masks
                            determine which self triggers are associated with each pin
                            of the LVDS output in that quartet.  There are 16 elements
                            corresponding to each of the 16 LVDS I/O pins. If
                            a pin is not in a quartet that is configured as
                            a <literal>SelfTriggers</literal> <literal>Output</literal>
                            it's mask is ignored.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdsoutput</seg>
                            <seg>Integer 0-0xffff</seg>
                            <seg>0</seg>
                            <seg>
                                If a pin is part of a quartet that's configured for
                                <literal>IORegister</literal>, <literal>Output</literal>,
                                The corresponding bit of this mask determines the
                                value of that pin.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>DAC  options</title>
                    <para>
                        Each module has a dedicated Digital to Analog Converter
                        (DAC).  The <literal>DAC</literal> LEMO output on the
                        module front panel reflects the output of this device.
                        These parameters control what that is.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>dacoutmode</seg>
                            <seg>Enumerated Value</seg>
                            <seg>ChSum</seg>
                            <seg>Determines what the input to the DAC is.
                            Legal values are
                            <literal>
                                Static, IPE, ChInput, MemOccupancy, ChSum, OverThrSum,
                                Ramp, Sin5MHz, Square
                            </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dacoutputlevel</seg>
                            <seg>Integer 0-16383</seg>
                            <seg>0</seg>
                            <seg>
                                If the output mode is <literal>Static</literal>,
                                the output is the DAC conversion of this value
                                as its input.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dacoutchannel</seg>
                            <seg>integer 0-63</seg>
                            <seg>0</seg>
                            <seg>If the DAC output mode is
                            <literal>ChInput</literal> this value selects the
                            channel input that is echoed on the DAC output.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Input conditioning</title>
                    <para>
                        Describes the parameters that control the relationship
                        between the raw ADC inputs and what the digitizers see.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>vgagain</seg>
                            <seg>List of four integers 0-40</seg>
                            <seg>0</seg>
                            <seg>If the module is equipped with variable gain
                            amplifiers on its input, each amplifier gain is common
                            between 16 inputs.  This list of parameters sets the
                            VGA Gain for groups of 16 channels.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>offsetcalibrationenable</seg>
                            <seg>Boolean value</seg>
                            <seg>true</seg>
                            <seg>Enable/disable the offset calibraion for each channel.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>channelenables</seg>
                            <seg>List of 64 booleans</seg>
                            <seg>[lrepeat true 64]</seg>
                            <seg>
                                For each channel when its corresponding list element
                                is true, the channel is enabled, otherwise it is
                                disabled.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dcoffsets</seg>
                            <seg>List of 64 floats 0-100.0</seg>
                            <seg>[lrepeat 50.0 64]</seg>
                            <seg>For each channel, this is the DC Offset applied
                            to the channels.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>triggerthresholds</seg>
                            <seg>64 element list of integers 0-8191</seg>
                            <seg>1023</seg>
                            <seg>
                                Channel trigger thresholds.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>inputpolarities</seg>
                            <seg>list of 64 enums</seg>
                            <seg>[lrepeat Negative 64]</seg>
                            <seg>Sets the polarity of the input pulse for each channel.
                            Valid values are <literal>Positive</literal>
                            and <literal>Negative</literal></seg>
                        </seglistitem>
                    </segmentedlist>
                                           
                </section>
                <section>
                    <title>Event Selection Options</title>
                    <para>
                        The module has several post trigger event filtering options
                        that can be set.  These options are exposed as:
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>energyskimlow</seg>
                            <seg>64 element integer list 0-65534</seg>
                            <seg>[lrepeat 0 64]</seg>
                            <seg>
                                Events in a channel with computed energies
                                less than this value (for that channel) are not
                                passed to the host.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>energyskimhigh</seg>
                            <seg>64 element integer list 0-65534</seg>
                            <seg>[lrepeat 65534 64]</seg>
                            <seg>
                                Events in a channel with computed energies
                                higher than this value (for that channel) are not
                                passed to the host. Thus the <literal>energyskimlow</literal>
                                and <literal>energyfilterhigh</literal> values
                                for each channel provide an energy cut between
                                which events are accepted and outside of which
                                they are rejected.  See, however
                                <literal>eventselector</literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>eventselector</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat All 64</seg>
                            <seg>
                                Selects which events (energy values) are
                                saved for each channel. Valid values for each
                                element of the list are
                                <literal>All, Pileup, EnergySkim</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>waveselector</seg>
                           <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat All 64</seg>
                            <seg>
                                Selects which waveforms are
                                saved for each channel. Valid values for each
                                element of the list are
                                <literal>All, Pileup, EnergySkim</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>coincidencemask</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat Disabled 64]</seg>
                            <seg>
                                Defines a concidence source for a trigger on each
                                channel.  Valid values are:
                                <literal>
                                    Disabled, Ch64Trigger, TRGIN,
                                    GlobalTriggerSource, ITLA, ITLB
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>anticoincidencemask</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeate Disabled 64</seg>
                            <seg>
                                Defines an anticoincidence source for a trigger
                                on each channel.  Valid values are:
                                <literal>
                                    Disabled, Ch64Trigger, TRGIN,
                                    GlobalTriggerSource, ITLA, ITLB
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>coincidencelength</seg>
                            <seg>List of 64 integer values in nanoseconds 8-524280</seg>
                            <seg>[lrepeat 100 64</seg>
                            <seg>
                                Defines, for each channel, the coincidence window
                                in nanoseconds for the coincidence and anti
                                coincidence trigger sources defined by
                                <literal>coincidencemask</literal>
                                and <literal>anticoincidencemask</literal>.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>DPP Processing parameters</title>
                    <para>
                        Firmware on the module processes raw, digitized wave forms
                        into pulse heights (energies).  This processing includes a
                        time filter and an energy filter.  The parameters
                        in this section are relevant to those two filters.
                    </para>
                    <para>
                        Figure 3  of the <literal>FELib PHA Parameters User Manual</literal>
                        is a useful description of these parameters and how they
                        drive signal processing.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>tfrisetime</seg>
                            <seg>64 element list of integers 4-250</seg>
                            <seg>[lrepeate 80 64]</seg>
                            <seg>
                                The rise time parameter for the time
                                fiter for each channel
                                expressed in digitizer samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>tfretriggerguard</seg>
                            <seg>64 element list of integers 0-1000</seg>
                            <seg>[lrepeat 0 64]</seg>
                            <seg>
                                The time filter retrigger guard for each
                                channel expressed in samples. 
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efrisetime</seg>
                            <seg>64 element list of integers 4-1625</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                The rise time parameter of the enegy filter
                                for each channel expressed in samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efflattoptime</seg>
                            <seg>64 element list of integers 4-375</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                The energy filter flattop time parameter
                                in units of samples for each channel.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpeakingpos</seg>
                            <seg>64 element list of integers 10-90</seg>
                            <seg>[lrepeat 50 64]</seg>
                            <seg>
                                The trapezoid peaking position for each channel
                                in percentage of the flattop time.  Note the
                                manual, at the time I'm writing this erroneously
                                expresses the limis on this parameter
                                at 0-100. 
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpeakingavg</seg>
                            <seg>list of 64 enumerated values</seg>
                            <seg>[lrepeat 1 64]</seg>
                            <seg>
                                Number of samples averaged to evaluate the
                                peak for each channel.  Legal values are
                                <literal>
                                    1, 4, 16, 64
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpolezero</seg>
                            <seg>list of 64 integers 4-65500</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                Pole zero adjustment of the digital shaping
                                amplifier for each channel in units of samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>effinegain</seg>
                            <seg>list of 64 floating point values 1.0-10.0</seg>
                            <seg>[lrepeat 1.0 64]</seg>
                            <seg>
                                Sets the digital fine gain for each channel.
                                The granularity of these values is
                                0.001.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>eflflimitation</seg>
                            <seg>64 element list of bools</seg>
                            <seg>[lrepeat false 64]</seg>
                            <seg>
                                When enabled for a channel, a low frequency
                                filter is applied to that channel for the
                                energy filter.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efbaselineavg</seg>
                            <seg>64 element list of enumerated values</seg>
                            <seg>[lrepeat 16 64]</seg>
                            <seg>
                                The number of samples averaged to compute the
                                signal baseline prior to the start of the
                                trapezoidal filter.  Legal values for each
                                element are:
                                <literal>0, 16, 64, 256, 1024, 4096, 16384</literal>.
                                Note that a value of <literal>0</literal>
                                fixes the baseline at zero.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efbaselineguardt</seg>
                            <seg>list of 64 integer values. 0-8000</seg>
                            <seg>[lrepeat 0 64]</seg>
                            <seg>
                                The time, for each channel, after the trapezoidal
                                filter before basline computation will resume.
                                These values are in units of nanoseconds.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpileupguardt</seg>
                            <seg>List of 64 integers 0-8000</seg>
                            <seg>[lrepeat 0 64</seg>
                            <seg>
                                For each channel, specifies, in ns, the guard time
                                that defines energy filter pileup.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
            </section>
        </section>
        <section id='sec.eventstruct'>
            <title id='sec.eventstruct.title'></title>
            <para>
                This section describes events written by the Readout program.
                These hits are encapsulated in NSCLDAQ ringitems.  When the event
                builder is  in use, additional event builder encapsulation
                will occur.
            </para>
            <para>
                Ring items are described in the NSCLDAQ documentation.
                This is in the form of an annotated header for
                <filename>DataFormat.h</filename>.  See e.g.
                <ulink url="https://docs.nscl.msu.edu/daq/newsite/nscldaq-11.3/r22906.html" />.
                In order to support event building, the ring items that encapslate
                hits include a body header.  The body header includes the hit timestamp
                and sourceid as well as a zero valued barrier type.
            </para>
            <para>
                The additional event builder encapsulation is described in the
                NSCLDAQ section on the event builder e.g.
                <ulink url='https://docs.nscl.msu.edu/daq/newsite/nscldaq-11.3/x4509.html' />
            </para>
            <para>
                This leaves to us documenting the format of the body of a hit:
            </para>
            <table>
                <title>Format of event body</title>
                <tgroup cols='2' align='left' colsep='1' rowsep='1'>
                    <colspec colname='type' />
                    <colspec colname='what' />
                    <thead>
                        <row>
                            <entry>Data Type</entry>
                            <entry>Contents</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of uint16_t's in the event</entry>
                        </row>
                        <row>
                            <entry>Variable.</entry>
                            <entry>Null terminated string that identifies the module</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Channel within the module the hit came from</entry>
                        </row>
                        <row>
                            <entry>uint64_t</entry>
                            <entry>Hit timestamp in nanoseconds</entry>
                        </row>
                        <row>
                            <entry>uint64_t</entry>
                            <entry>raw timestamp only meaningful if selected</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>fine timestamp only meaningful if selected</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Peak height (energy)</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Low priority flags. Only meaningful if selected.</entry>
                        </row>
                        <row>
                            <entry>uint16_t></entry>
                            <entry>High priority flags. Only meaningful if selected.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Down sample selection code. Only meaningful if selected</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>
                                Fail flags.  Only meaningful if selected</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Analog probe type 1 - only meaningful if
                            analog probe 1 is selected for readout</entry>
                        </row>
                        <row>
                            <entry>
                                uint32_t
                            </entry>
                            <entry>Number of samples of analog probe 1 data.
                            This is zero if analog probe 1 is not selecte.</entry>
                        </row>
                        <row>
                            <entry>variable number of uint32_t values</entry>
                            <entry>Analog probe 1 values.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Analog probe type 2 - only meaningful if
                            analog probe 2 is selected for readout</entry>
                        </row>
                        <row>
                            <entry>
                                uint32_t
                            </entry>
                            <entry>Number of samples of analog probe 1 data.
                            This is zero if analog probe 2 is not selected.</entry>
                        </row>
                        <row>
                            <entry>variable number of uint32_t values</entry>
                            <entry>Analog probe 1 values.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Digital probe type 1 - only meaningful if digital probe 1 is selected
                            </entry>
                        </row>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of samples in digital probe 1</entry>
                        </row>
                        <row>
                            <entry>variable number of uint8_ts</entry>
                            <entry>Digital probe sample.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Digital probe type 2 - only meaningful if digital probe 2 is selected
                            </entry>
                        </row>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of samples in digital probe 2</entry>
                        </row>
                        <row>
                            <entry>variable number of uint8_ts</entry>
                            <entry>Digital probe sample.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Digital probe type 3 - only meaningful if digital probe 3 is selected
                            </entry>
                        </row>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of samples in digital probe 3</entry>
                        </row>
                        <row>
                            <entry>variable number of uint8_ts</entry>
                            <entry>Digital probe sample.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Digital probe type 4 - only meaningful if digital probe 4 is selected
                            </entry>
                        </row>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of samples in digital probe 4</entry>
                        </row>
                        <row>
                            <entry>variable number of uint8_ts</entry>
                            <entry>Digital probe sample.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                Note that if needed an additional byte will pad out the end of the
                event to bring it to an even number of <type>uint16_t</type>.
                However, since there are an even number of digital probes,
                all with the same length, I don't think this padding ever happens.
            </para>
        </section>
    </chapter>
    <chapter id='ch.spectcl'>
        <title id='ch.spectcl.title'>
            Configuring SpecTcl
        </title>
        <para>
            Some classes have been written to make the unpacking of raw parameters
            from hits within an event built event simple.
            With SpecTcl's event processing pipeline architecture, once raw
            events have been unpacked into parameters and accessible data structures,
            it is simple to add additional event processors to the pipeline
            to perform arbitrary computations.
        </para>
        <para>
            This chapter will describe:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  The support classes you need to know to unpack digitizer data. 
               </para>
            </listitem>
            <listitem>
               <para>
                  How to obtain a copy of the SpecTcl Skeleton you will modify
                  to create a version of SpecTcl capable of analyzing the event
                  built data.
               </para>
            </listitem>
            <listitem>
               <para>
                  How to modify the Makefile so that the classes written to
                  unpack data from the digitizers can be incorporated intothe built
                  SpecTcl.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            SpecTcl documentation is available in
            <ulink url='http://docs.nscl.msu.edu/daq' />.
            I recommend using a release of SpecTcl version 5.12.  This version
            has the infrastructure to unpack event built data needed by
            the classes we'll use, as well as the new QtPi displayer as an option
            if you want capabilities beyond those offered by <literal>Xamine</literal>.
        </para>
        <para>
            Note that a complete example is provided in the <filename>tclreadout/SpecTcl</filename>
            subdirectory of the source tree.
            <filename></filename>
        </para>
        <section>
            <title>Unpacking classes</title>
            <para>
                The <filename>libCaenVxUnpackers.a</filename> library provides
                classes that understand how to unpack data from the
                event built data for the CAEN Digitizers.  This section
                describes those classes.
            </para>
            <para>
                The two main classes you will need are
                <classname>VX2750ModuleUnpacker</classname> and
                <classname>VX2750EventBuiltEventProcessor</classname>.
            </para>
            <para>
                <classname>VX2750ModuleUnpacker </classname> is responsible
                for unpacking hits from a module into a set of
                parameters and internal data.  Energies, and timestamps, for
                example are unpacked into SpecTcl parameters and can be directly
                histogrammed.  Analog and digital probe data, however cannot and
                are loaded into internal data where event processors later in the
                pipeline can fetch them, if needed, to produce parameters or,
                in the case of traces, load them on demend into spectra, so they
                can be visualized.
            </para>
            <para>
                A class that you normally won't need to directly instantiate,
                <classname>VX2750EventProcessor</classname> is responsible
                for ensure that module unpackers are called with
                a pointer to data for a hit.  The event processor is also
                responsible for informing the unpacker when event processing begins
                and, therefore, internal data can be cleared.
            </para>
            <para>
                Separate sections will describe the methods you will need
                to interact with both the unpacker and the event built event
                processor.
            </para>
            <section>
                <title>The <classname>VX2750ModuleUnpacker</classname> class</title>
                <para>
                    Given a pointer to the data from a module,
                    <classname>VX2750ModuleUnpacker</classname> instances
                    <methodname>unpackHit</methodname> method cumulatively
                    unpacks hits into SpecTcl parameters and internal data until
                    the <methodname>reset</methodname> is invoked.  Normally
                    <methodname>reset</methodname> if invoked by framing code
                    as processing of a new event begins.
                </para>
                <para>
                    Methods provide access to internal data for subsequent
                    stages of SpecTcl's event processing pipeline.
                    Here are the important methods of
                    <classname>VX2750ModuleUnpacker</classname>.
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>VX2750ModuleUnpacker</methodname>
                           <methodparam>
                               <type>const char*</type><parameter>moduleName</parameter>
                           </methodparam>
                           <methodparam>
                               <type>const char*</type><parameter>paramBaseName</parameter>
                           </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                                Constructs a new instance.  <parameter>moduleName</parameter>
                                is the name of the module that will be unpacked.
                                Attempting to pass data for another module to
                                <methodname>unpackHit</methodname>
                                will result in an exception.
                                The <parameter>paramBaseName</parameter> parameter
                                provides the base parameter name of the SpecTcl
                                parameters this object will produce.
                           </para>
                           <para>
                                The unpacker, when called for each hit in an event,
                                will produce parameter arrays for the timestamp
                                in nanoseconds, the raw timestamp and the fine timestamp
                                as well as the energy.  Suppose, that
                                A hit is constructed with a parameter base value
                                of <literal>someModule</literal>;  construction
                                will build Tree Parameter arrays, containing 64
                                elements (one for each channel), that are named
                                <literal>someModule.ns</literal>,
                                <literal>someModule.rawTime</literal>,
                                <literal>someModule.fineTime</literal> and
                                <literal>someModule.energy</literal>.
                           </para>
                           <para>
                            Note that only elements for which hits have been
                            seen will have valid values and that SpecTcl will not
                            histogram parameters that don't have valid values.
                            Furthermore, with the exception of the nanosecond time and
                            energy, the readout must have enabled readout of the other
                            parameters for those to have meaningful values.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void</type>
                          <methodname>reset</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Called to reset all of the internal data. Note that
                            SpecTcl's begin event processing invalidates the
                            tree parameter arrays in O(1) time so these are not
                            touched by <methodname>reset</methodname>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const void*</type>
                          <methodname>unpackHit</methodname>
                          <methodparam>
                              <type>const void*</type><parameter>pData</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Processes data from a hit cumulatively into the
                            Tree parameter arrays and internal data.
                            Returns a pointer to the byte just after the hit.
                            If the data does not point to a hit from the
                            correct module a <classname>std::logic_error</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint64_t </type>
                          <methodname>getChannelMask</methodname>
                          <void />
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a bitmask of the channels that have been
                            passed to <methodname>unpackHit</methodname>
                            since the last call to <methodname>reset</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::set&lt;unsigned&gt;</type>
                          <methodname>getChannelSet</methodname>
                          <void />
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as <methodname>?getChannelMask</methodname>
                            but the returned value is a set containing the
                            numbers of all channesl that have been processed.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t </type>
                          <methodname>getLowPriorityFlags</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>channel</parameter>
                              <modifier> const</modifier>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Gets the low priority flag value for channel
                            <parameter>channel</parameter>.  If the channel
                            has had a hit since the last <methodname>reset</methodname>,
                            or if the channel value is out of range,
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                           <para>
                            Note that if the low priority flags
                            were not selected to be read out, this value is
                            meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t </type>
                          <methodname>getHighPriorityFlags</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>channel</parameter>
                              <modifier> const</modifier>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Gets the high priority flag value for channel
                            <parameter>channel</parameter>.  If the channel
                            has had a hit since the last <methodname>reset</methodname>,
                            or if the channel value is out of range,
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                           <para>
                            Note that if the low priority flags
                            were not selected to be read out, this value is
                            meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t </type>
                          <methodname>getDownSampleSelection</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>channel</parameter>
                              <modifier> const</modifier>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Gets down sampling code for 
                            <parameter>channel</parameter>.  If the channel
                            has had a hit since the last <methodname>reset</methodname>,
                            or if the channel value is out of range,
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                           <para>
                            Note that if the down sampling code
                            was not selected to be read out, this value is
                            meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getFailFlags</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the fail flag bit mask for <parameter>channel</parameter>.
                            If the event does not have a hit from
                            <parameter>channel</parameter>, or <parameter>channel</parameter>
                            is out of range, <classname>std::invalid_argument</classname>
                            is thrown.  Note that if you have not enabled error
                            flags in the event readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getAnalogProbe1Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the type code for analog probe 1.
                            Note that if analog probe 1 is not enabled for the
                            event readout, this will be a meaningless value.
                            If <parameter>channel</parameter> is not present
                            in the event or out of range;
                            <classname>std::invalid_argument</classname>
                            will be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint32_t&gt;&amp;</type>
                          <methodname>getAnalogProbe1Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples from analog probe 1.  If
                            analog probe 1 is not enabled for readout, this will
                            reference a zero length vector.  If the
                            <parameter>channel</parameter> is out of range or has not
                            provided a hit to this event,
                            <classname>std::invalid_argument</classname> will
                            be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                                        <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getAnalogProbe2Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the type code for analog probe 2.
                            Note that if analog probe 2 is not enabled for the
                            event readout, this will be a meaningless value.
                            If <parameter>channel</parameter> is not present
                            in the event or out of range;
                            <classname>std::invalid_argument</classname>
                            will be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint32_t&gt;&amp;</type>
                          <methodname>getAnalogProbe2Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples from analog probe 2.  If
                            analog probe 2 is not enabled for readout, this will
                            reference a zero length vector.  If the
                            <parameter>channel</parameter> is out of range or has not
                            provided a hit to this event,
                            <classname>std::invalid_argument</classname> will
                            be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getDigitalProbe1Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Get the probe type code for digital probe 1.
                            If <parameter>channel</parameter> is not present
                            or out of range <classname>std::invalid_argument</classname>
                            is thrown.  Note that if digital probe 1 is not
                            enabled for readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint8_t&gt;&amp;</type>
                          <methodname>getDigitalProbe1Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples for digital probe 1.  If
                            digital probe 1 is not enabled for readout, this
                            will be a reference to a zero length vector.
                            If <parameter>channel</parameter> is out of range
                            or not present in the event
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getDigitalProbe2Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Get the probe type code for digital probe 2.
                            If <parameter>channel</parameter> is not present
                            or out of range <classname>std::invalid_argument</classname>
                            is thrown.  Note that if digital probe 2 is not
                            enabled for readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint8_t&gt;&amp;</type>
                          <methodname>getDigitalProbe2Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples for digital probe 2.  If
                            digital probe 2 is not enabled for readout, this
                            will be a reference to a zero length vector.
                            If <parameter>channel</parameter> is out of range
                            or not present in the event
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getDigitalProbe3Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Get the probe type code for digitial probe 3.
                            If <parameter>channel</parameter> is not present
                            or out of range <classname>std::invalid_argument</classname>
                            is thrown.  Note that if digital probe 3 is not
                            enabled for readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint8_t&gt;&amp;</type>
                          <methodname>getDigitalProbe4Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples for digital probe 4.  If
                            digital probe 4 is not enabled for readout, this
                            will be a reference to a zero length vector.
                            If <parameter>channel</parameter> is out of range
                            or not present in the event
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getDigitalProbe1Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Get the probe type code for digitial probe 1.
                            If <parameter>channel</parameter> is not present
                            or out of range <classname>std::invalid_argument</classname>
                            is thrown.  Note that if digital probe 1 is not
                            enabled for readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint8_t&gt;&amp;</type>
                          <methodname>getDigitalProbe1Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples for digital probe 1.  If
                            digital probe 1 is not enabled for readout, this
                            will be a reference to a zero length vector.
                            If <parameter>channel</parameter> is out of range
                            or not present in the event
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
            <section>
                <title>The <classname>VX2750EvenBuiltEventProcessor</classname> class</title>
                <para>
                    Normally, you will not need to call
                    <classname>VX2750ModuleUnpacker</classname>::<methodname>unpackHit</methodname>
                    directly.  Since you will normally attach SpecTcl to the
                    output of the event builder, you will instantiate
                    <classname>VX2750ModuleUnpacker</classname> objects and register
                    them with an instance of the
                    <classname>VX2750EventBuiltEventProcessor</classname>.
                </para>
                <para>
                    The <classname>VX2750EventBuiltEventProcessor</classname>
                    understands the fragment wrapping of the event builder output.
                    It processes event built events and dispatches to event
                    processors that are registered to handle specific
                    source ids (in this case modules).
                </para>
                <para>
                    Usually you will:
                </para>
                <orderedlist>
                    <listitem>
                       <para>
                          Construct a <classname>VX2750EventBuiltEventProcessor</classname>.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          For each module, associated a module name with
                          a source id and provide a base parameter name
                          from which all of the parameters it provides
                          will be constructed.
                       </para>
                    </listitem>
                    
                    <listitem>
                       <para>
                          Register your
                          <classname>VX2750EventBuiltEventProcessor</classname>
                          with SpecTcl's event processing pipeline so that it
                          will gain control for each event.
                       </para>
                    </listitem>
                </orderedlist>
                <para>
                    Here are the signatures of the method in
                    <classname>VX2750EventBuiltEventProcessor</classname>
                    you'll need to use:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> VX2750EventBuiltEventProcessor</methodname>
                        
                           <methodparam>
                               <type>std::string</type><parameter>baseName</parameter>
                           </methodparam>
                            
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                              Constructor.  The <parameter>baseName</parameter>
                              provides the base name for parameters that can be
                              used for clock/synchronization diagnostics.
                              The class is derived from the
                              <classname>CEventBuilderEventProcessor</classname>.
                              The diagnoistic parameters produced are
                              described in
                              <ulink url='https://docs.nscl.msu.edu/daq/newsite/spectcl-5.0/pgmref/r8783.html' />
                              in the SpecTcl programming reference manual.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void </type>
                          <methodname>addEventProcessor</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const std::string&amp; </type><parameter>moduleName</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const std::string </type><parameter>paramBasename</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                               This method constructs a
                               <classname>VX2750ModuleUnpacker</classname>
                               for the module <parameter>moduleName</parameter>.
                               The resulting object is then wrapped in a
                               <classname>VX2750EventProcessor</classname>
                               which will poduce parameters with a base name
                               <parameter>paramBasename</parameter>
                           </para>
                           <para>
                            The event processor will be registered to
                            handle fragments from <parameter>sourceId</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void </type>
                          <methodname>addEventProcessor</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>VX2750ModuleUnpacker&amp;</type><parameter>unpacker</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            The prior overload is the simplest way to register
                            a module with the SpecTcl unpacking framwork.
                            Using it, however, loses access to the additional
                            data that is unpacked for each event that is not
                            put in a SpecTcl parameter (e.g. the analog probes).
                           </para>
                           <para>
                            This method, takes a constructed module unpacker,
                            wraps it in an event processor that will produce
                            parameters using the module name as the parameter base name.
                            The resulting event processor is then registered to
                            handle data from <parameter>sourceID</parameter>.
                           </para>
                           <para>
                            Using this allows you to retain the event unpacker
                            object for use in a later event processor.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>
        <section>
            <title>Obtaining and modifying the skeleton</title>
            <para>
                In this and subsequent sections we assume that your SpecTcl
                installation top level directory is pointed to by an environment
                variable <literal>SPECTCLHOME</literal>.  This is simply a convenience
                to make it simpler to describe the actions you need to take.
            </para>
            <para>
                To obtain a copy of the SpecTcl skeleton for your viersion:
            </para>
            <example>
                <title>Obtaining a copy of the SpecTcl skeleton</title>
                <programlisting>
mkdir myspectcl
cp -R $SPECTCLHOME/Skel/* .

                </programlisting>
            </example>
            <para>
                This should provide a number of files, many of which are used
                to extend the QtPy display program, if desired (see e.g.
                <ulink url='https://docs.nscl.msu.edu/daq/newsite/qtpy/index.html'/>).
                The files we'll need to play with to tailor SpecTcl to handle our
                data are:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      <filename>MySpecTclApp.cpp</filename>; a skeletal application
                      class in whose methods SpecTcl extensions and customizations
                      are done.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      <filename>Makefile</filename>.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                This section will show how to modify the <filename>MySpecTclApp.cpp</filename>
                file and the next will show modifications needed to the
                <filename>Makefile</filename> to pull in headers and libraries
                needed to support the modifications we've made.
            </para>
            <para>
                Here is a <filename>MySpecTclApp.cpp</filename> modified to
                analyze data from a single module.  The discussion following
                this example will describe how to extend this to a system
                with additional modules.  The full example is in the
                <filename>tclreadout/SpecTcl</filename> subdirectory of the
                source tree.
            </para>
            <example>
                <title><filename>MySpecTclApp.cpp</filename> modified for a single module</title>
                <programlisting>

#include &lt;VX2750EventBuiltEventProcessor.h&gt;   <co id='spectclapp.includes' />
#include &lt;VX2750ModuleUnpacker.h&gt;

...


void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)  <co id='spectclapp.pipeline' />
{

    auto pTopLevel = new                                        <co id='spectclapp.builtproc' />
      caen_spectcl::VX2750EventBuiltEventProcessor("diagnostic");
      
    auto pAdc1 =                                                 <co id='spectclapp.module' />
        new caen_spectcl::VX2750ModuleUnpacker("adc1", "adc1-params");      
    pTopLevel-&gt;addEventProcessor(1, *pAdc1);                   <co id='spectclapp.regmodule' />
    
    RegisterEventProcessor(*pTopLevel, "Raw");                    <co id='spectclapp.regprocessor' />
}


                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='spectclapp.includes' >
                    <para>
                        <filename>MySpecTclApp.cpp</filename>
                        must incorporate the class definitions for the
                        <classname>VX2750EventBuiltEventProcessor</classname>
                        and the
                        <classname>VX2750ModuleUnpacker</classname>.  These headers
                        will also spur some of our
                        <filename>Makefile</filename> modifications.
                    </para>
                </callout>
                <callout arearefs='spectclapp.pipeline' >
                    <para>
                        In most cases, <classname>MySpecTclApp.cpp</classname>
                        only needs to be modified to describe the
                        <firstterm>Event analysis pipeline</firstterm>
                        used for an application.  The event analysis
                        pipeline is described in detail in
                        the SpecTcl programming guide:
                        <ulink url='https://docs.nscl.msu.edu/daq/newsite/spectcl-5.0/pgmguide/index.html' />.
                    </para>
                    <para>
                        To summarize, however, the event processing pipeline is
                        a logical sequence, pipeline, that takes as input, raw
                        event data and produces as output parameters that SpecTcl's
                        histogramming engine uses to increment spectra defined by
                        the user.  Each stage of the pipeline has available, not
                        only the raw event, but the parameters and data
                        produced by prior elements of the pipeline.
                    </para>
                    <para>
                        Elements of the event processing pipeline are called,
                        unoriginally enough, <firstterm>Event Processors</firstterm>
                        and are all derived, ultimately, from the
                        <classname>CEventProcessor</classname> class.
                        In <methodname>CreateAnalysisPipeline</methodname>,
                        <filename>MySpecTclApp.cpp</filename> is modified to
                        define event processors and the order in which they
                        execute for each event.
                    </para>
                    <para>
                        SpecTcl-5.0 supports dynamic event processing pipelines
                        (composing pipelines from either compiled in event processors
                        or event processors dynamically loaded from whared libraries
                        at run time.)  This is beyond the scope of this document
                        and is described in chapter 12 of the
                        programming guide.
                    </para>
                </callout>
                <callout arearefs='spectclapp.builtproc' >
                    <para>
                        This line creates a
                        <classname>VX2750EventBuiltEventProcessor</classname>.
                        As previously descdribed, this event processor knows
                        how to dig event fragments from a built event and
                        pass them on to processors registered for each
                        source id.  It also maintains diagnostic parameters
                        that allow you to monitor the synchronization of
                        the clocks in each event source.
                    </para>
                    <para>
                        Recall that in this application, each module is an
                        event source with its own  unique source id.
                    </para>
                </callout>
                <callout arearefs='spectclapp.module' >
                    <para>
                        A module unpacker knows how to unpack the data from a
                        single module.  It is normally wrapped in a
                        <classname>VX2750EventProcessor</classname> object
                        which, given a pointer to the data for a fragment,
                        computes the pointer to the raw data for the module
                        and passes that to the module unpacker it wraps.
                    </para>
                    <para>
                        In this line we create a <classname>VX2750ModuleUnpacker</classname>
                        for the <literal>adc1</literal> module (the name
                        must match the module name used in the readout program),
                        and specify that parameters produced by this unpacker
                        will be given names that start with
                        <literal>adc1-params.</literal>.
                    </para>
                    <para>
                        If you wanted to perform processing on data this
                        module unpacks but does not put in parameters, you
                        could take the pointer to the unpacker and pass it
                        to another event processor put in the pipeline
                        after the raw parameter unpacking.
                    </para>
                    
                </callout>
                <callout arearefs='spectclapp.regmodule' >
                    <para>
                        Registers the unpacker we created to handle data from
                        source id <literal>1</literal>.  This too must match
                        the source id specified for this module in the
                        Readout program.
                    </para>
                    <para>
                        In a system with more than one digitizer simply instantiate
                        a module unpacker for each digitizer and register each one
                        to process data from the source id associated with its data.
                    </para>
                </callout>
                <callout arearefs='spectclapp.regprocessor' >
                    <para>
                        Appends the event built event processor to the event
                        processing pipeline.  If you have additional processing
                        stages you would create event processors for each stage
                        and register them in the order in which they will be
                        called.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Building the tailored SpecTcl</title>
            <para>
                The <filename>Makefile</filename> in the skeleton is
                a starting point from which a tailored Makefile can be made.
                In the case of the <filename>MySpecTclApp.cpp</filename>
                we tailored in the previous section, we must:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      Specify the location of the additional header files
                      that are required.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Specify the location and name of the additional library
                      we need to pull the classes into our SpecTcl.
                      
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                The next example shows these modifications.  We assume that
                the support software has been installed in
              <filename>/usr/opt/lbnl</filename>
            </para>
            <example>
                <title>
                    Makefile for SpecTcl
                </title>
                <programlisting>
INSTDIR=/usr/opt/spectcl/5.12-008

CAEN_ROOT=/usr/opt/lbnl                      <co id='spmake.base' />

# Skeleton makefile for 3.1

include $(INSTDIR)/etc/SpecTcl_Makefile.include

#  If you have any switches that need to be added to the default c++ compilation
# rules, add them to the definition below:

USERCXXFLAGS=-I$(CAEN_ROOT)/include      <co id='spmake.includes' />

#  If you have any switches you need to add to the default c compilation rules,
#  add them to the defintion below:

USERCCFLAGS=$(USERCXXFLAGS)

#  If you have any switches you need to add to the link add them below:

USERLDFLAGS=-L$(CAEN_ROOT)/lib -lCaenVxUnpackers  <co id='spmake.libs' />
#
#   Append your objects to the definitions below:
#

OBJECTS=MySpecTclApp.o

#
#  Finally the makefile targets.
#


SpecTcl: $(OBJECTS)
        $(CXXLD)  -o SpecTcl $(OBJECTS) $(USERLDFLAGS) \
        $(LDFLAGS)


clean:
        rm -f $(OBJECTS) SpecTcl

                </programlisting>
            </example>
            <para>
                The SpecTcl skeleton Makefile provides three variables that,
                in many cases, are all that need to be modified to
                tailor the <filename>Makefile</filename>:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      <literal>USERCXXFLAGS</literal>  provides additional
                      compilations flags to the C/C++ compiler used by the
                      default compilation rules.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      <literal>USELDFLAGS</literal>, similarly, provide additional
                      flags passed to the link step of the SpecTcl Build.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      <literal>OBJECTS</literal> is a list of objects that must
                      be built for SpecTcl to be tailored.  without additional
                      rules, a file specified in <literal>OBJECTS</literal> will
                      be built from sources using the default compilation rules
                      SpecTcl's Makefile establishes.  IF these cannot be made to
                      work by setting <literal>USERCXXFLAGS</literal>, the user
                      may certainly supply explicit compilation rules.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                In our example, we don't introduce any additional compiled object.
                So:
            </para>
            <calloutlist>
                <callout arearefs='spmake.base' >
                    <para>
                        In order to make our definitions easy to change, we first
                        define the Makefile varaible <literal>CAEN_ROOT</literal>
                        to be the top level of the directory in which we
                        installed the CAEN support software.
                    </para>
                </callout>
                <callout arearefs='spmake.includes' >
                    <para>
                        Defines <literal>USERCXXFLAGS</literal>, the additional
                        compilation flags we need to include the
                        <filename>include</filename> directory of the
                        header search path for the compilers.
                    </para>
                </callout>
                <callout arearefs='spmake.libs' >
                    <para>
                        Defines <literal>USERLDFLAGS</literal>, the additional
                        link flags we need to add the CAEN unpacker library directory
                        to the library search path and explicity requests
                        that
                        <filename>libCaenVxUnpackers.a</filename> be searched
                        to satisfy external references.
                    </para>
                    <para>
                        If the library ever becomes a shared object we'd need
                        to add <literal>-Wl,-rpath=$(CAEN_ROOT)/lib</literal>
                        to the <literal>USERLDFLAGS</literal>.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </chapter>
    <appendix id='app.internals'>
        <title>Software structure</title>
        <para>
            This documentation of the software internals separates into two
            mostly independent chunks.  Support for Readout and support for
            SpecTcl.
        </para>
        <para>
            In all cases a layered approach was taken.  This provides a realtively
            easy to use system which may not perform at the fastest possible speed,
            but can later be optimized either by using the lower layers of software
            directly or by transparently optimizing some of the lower layers for
            the upper layers.
        </para>
        <section>
            <title>Readout Software</title>
            <para>
                The software described in this section is in
                <filename>libCaenVx2750.a</filename>
            </para>
            <para>
                The CAEN support for the VXxxxx digitizers with DPP-PHA firmware
                is supplied as ilbraries that are installed either on the host
                system or in the container image.  This support consists of two
                libraries.  The first communicates with the digitizer and the
                second provides a filesystem like image of the digitizer parameter
                space.
            </para>
            <para>
                On problem with the CAEN library support is that since parameters
                are file system path-like names and values are strings, errors
                can only be detected at run-time.  Two classes have been layered on
                top of the bas CAEN support, in the <literal>caen_nscldaq</literal>
                namespace:
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>Dig2Device</classname></term>
                   <listitem>
                       <para>
                        Provides basic communication support.  This class establishes
                        communication with boards and provides separated access
                        to the chunks of the digitizer filesystem that provide
                        parameters for different levels of acces.
                       </para>
                       <para>
                        For example, there are methods that write/read digitizer
                        level parameters, and methods that write/read channel level
                        parameters.  Similarly some methods control the LVDS I/Os
                        on the front panel, while others provide support to configure
                        the module for readout and to read individual events from
                        the module.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>VX2750Pha</classname></term>
                   <listitem>
                       <para>
                        This provides enumerated contants and methods which
                        provide access to teach of the parameters in the digitizer.
                        Note that since this is derived from <classname>Dig2Device</classname>,
                        should CAEN introduce additional parameters, they can be
                        directly accessed via the methds of that class until
                        appropriate methods are added to
                        <classname>VX2750Pha</classname>.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                There are a large number of parameters that can/must be
                configured to get the digitizer to do what you want it to do.
                The configuration for a single module is captured in a
                <classname>VX2750PHAConfiguration</classname> object.
                This object is agnostic about how it is configured.
                Support for creating and manipulating configurations using the
                Tcl scripting language is provided by
                <classname>VX2750TclConfig</classname>.
            </para>
            <para>
                Initially I wanted to be able to configure the modules using
                the same XML file produced by the COMPASS program and there
                is initial, untested code in <classname>VX2750XMLConfig</classname>
                to do that.  However the XML definition is not described anywhere and
                there are specific, important parameters I don't understand how
                to extract from that file.  The specification for the XML file is
                internal to the COMPASS group and, at least for the prior generation
                of digitizers, has changed from version to version leaving a
                full implementation of <classname>VX27850XMLConfig</classname>
                vulnerable to COMPASS updates.
            </para>
            <para>
                The Readout framework chosen requires a custom trigger and
                readout code.  The trigge tells the framework when it is appropriate
                to invoke the readout code.  The framework takes care of packaging the
                data read into ringitems an putting them into ringbufers where they
                can serve as input to the event builder.
            </para>
            <para>
                The classes at this level of the code are:
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>VX2750EventSegment</classname></term>
                   <listitem>
                       <para>
                        Knows how to read data when it is available in a single
                        module.  This uses a configuration object to initialize the
                        modules.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CAENVX2750PhaTrigger</classname></term>
                   <listitem>
                       <para>
                        Knows how to determine if a single module has
                        data.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Since, in general, a system consists of several modules,
                The following classes are containers which support multi-module
                setups.
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>VX2750MultiTrigger</classname></term>
                   <listitem>
                       <para>
                        Contains several indivdual module trigger objects.  In a single
                         poll, makes available thet set of readable modules.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>VX2750MultiModuleEventSegment</classname></term>
                   <listitem>
                       <para>
                        Contains several individual module event segments and
                        creates a multi trigger from them.  When called, it will
                        invoke the read methods of all of the event segments in
                        each module that has data.
                       </para>
                       <para>
                        This latter is done in a way the the event in each module
                        is treated as a single ring item.  The Readout framework
                        has a mechanism for a reader to specify that, upon providing
                        data it can read more data without the need to poll the trigger.
                        This mechanism is used by
                        <classname>VX2750MultiModuleEventSegment</classname>.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>SpecTcl Support</title>
            <para>
                SpecTcl support requires, at a minimum, some user code that can
                unpack raw data (in this case from the event builder) into
                a set of parameters.  These parameters are then fed to SpecTcl's
                histograming engine which, using spectrum definitions gates and
                gates applied to spectra maintains histograms.  The classes described
                in this section are in <filename>libCaenVxUnpackers</filename>.
            </para>
            <para>
                Histograms can be dynamically created as can gates snd the application
                of those gates to conditionalize spectrum increments.  
            </para>
            <para>
                SpecTcl accomplishes this mapping of raw event data to parameters
                via a programmatic scheme called the <firstterm>Data Analysis Pipeline</firstterm>.
                As the name implies the pipeline is made up of stages.  Each stage
                of the pipeline has access, not only to the raw event data, but the
                parameters that have been been produced by prior stages of the pipeline.
            </para>
            <para>
                While the DPP-PHA firmware has relatively few parameters that can
                be unpacked directly from its data (time and pulse height), depending
                on the items selected for readout, it can produce data that may be
                useful to other stage of the pipeline.  F
            </para>
            <para>
                For example, you can select to read the waveforms that were inputs
                to the DPP-PHA algorithm as well as some of the intermediate data.
                Computations could be done on these traces or a spectrum could be
                set-aside to be used to display waveforms on demand.
            </para>
            <para>
                The SpecTcl support provides software that knows how to unpack
                an event fragment or <firstterm>hit</firstterm> from a digitizer.
                It also provides framing software that is cognizant of event boundaries
                and calls appropriate unpacking software for each module throughout the
                hits the event builder has determined constitute an event.
            </para>
            <para>
                The relavent classes are:
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>VX2750ModuleUnpacker</classname></term>
                   <listitem>
                       <para>
                        Given a pointer to raw hit data unpacks the data from
                        the hit.  This class produces four  parameters for each
                        channel that's hit:  The nanosecond time, the raw time
                        the fine timestamp and the energy.
                       </para>
                       <para>
                        In addition to these parameters, internal data is maintained
                        for all other information the digitizer can produce.
                        <firstterm>Getter</firstterm> methods allow access
                        to these data.  You can imagine that in creating one or more
                        module unpackers, you might store pointers or references
                        to them in downstream elements of the analysis pipeline where
                        additional information could be extracted.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>VX2750EventProcessor</classname></term>
                   <listitem>
                       <para>
                        An event processor which, given a pointer to the body of
                        an event fragment invokes an unpacker to unpack data from
                        that hit.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>VX2750EventBuiltEventProcessor</classname></term>
                   <listitem>
                       <para>
                            This event processor holds a collection of
                            <classname>VX2750EventProcessor</classname> objects.
                            It accepts the body of an event from the event builder
                            and iterates over the fragments.  For each fragment,
                            the fragment's source id is used to select a
                            <classname>VX2750EventProcessor</classname> to use
                            to unpack the data in that fragment.
                       </para>
                       <para>
                        THe source id, in the readout scheme represents a module.
                        It is possible for an event to have more thano n e hit from
                        a module...in which case the module's unpacker is called
                        more than once per event.  Presumably this fill in data from
                        several channels in the module.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>To Do:</title>
            <para>
                If possible, with a bit of close cooperation from the CAEN
                Compass team, I'd like to revisit the possibility of configuring
                the system from a COMPASS XML file.
            </para>
            <para>
                Initializing a module takes too much time (my opinion).  This is
                done at the beginning of each run. I can see two improvements
                in this process:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Do a full initialization only on start up and scoreboard
                      changes to the configuration, only programming those at the
                      beginning of a run.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Support multichannel settings.   The CAEN parameter
                      'filesystem' provides a method to set several channel
                      level parameters to same value in a single transaction.
                      Supporting this <emphasis>could</emphasis> reduce the
                      number of device transactions needed for a full initialization.
                   </para>
                </listitem>
                
            </orderedlist>
        </section>
    </appendix>
    <appendix>
        <title>Class reference</title>
        <para>
            This appendix provides class reference material for the classes
            that make up both the NSCLDAQ and SpecTcl support.
            The two sections of man pages are
            <literal>3daq</literal> which cover classes that make up the
            DAQ support and <literal>3spectcl</literal> which provides reference
            material for SpecTcl class support.
        </para>
        <section>
            <title>NSLCDAQ Support (3daq)</title>
            <refentry>
               <refmeta>
                  <refentrytitle>caen_nscldaq::Dig2Device</refentrytitle>
                  <manvolnum>3daq</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>caen_nscldaq::Dig2Device</refname>
                  <refpurpose>Low Level Access To Digitizers</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;Dig2Device.h&gt;
namespace caen_nscldaq {
    void set_tracing(bool onoff) ;
    
    class Dig2Device {
    private:
        std::uint64_t m_deviceHandle;
        std::uint64_t m_endpointHandle;
    public:
        Dig2Device(const char* hostOrPid, bool isUsb = false);
        virtual ~Dig2Device();
        
        
        void SetValue(const char* parameterName, const char* value) const;
        void SetValue(const char* parameterName, int  value) const;
        void SetValue(const char* parameterName, std::uint64_t value) const;
        void SetValue(const char* parameterName, double value) const;
        void SetValue(const char* parameterName, bool value) const;

        
        void SetDeviceValue(const char* devParName, const char* value) const;
        void SetDeviceValue(const char* devParName, int value) const;
        void SetDeviceValue(const char* devParName, std::uint64_t value) const;
        void SetDeviceValue(const char* devParName, double value) const;
        void SetDeviceValue(const char* devParName, bool value) const;

        
        void SetChanValue(unsigned chan, const char* chanParName, const char* value) const;
        void SetChanValue(unsigned chan, const char* chanParName, int value) const;
        void SetChanValue(unsigned chan, const char* chanParName, std::uint64_t value) const;
        void SetChanValue(unsigned chan, const char* chanParName, double value) const;
        void SetChanValue(unsigned chan, const char* chanParName, bool value) const;

        
        void SetLVDSValue(unsigned quartet, const char* LVDSName, const char* value) const;
        void SetLVDSValue(unsigned quartet, const char* LVDSName, int value) const;
        void SetLVDSValue(unsigned quartet, const char* LVDSName, std::uint64_t value) const;
        void SetLVDSTriggerMask(unsigned maskNo, std::uint64_t mask) const;
        
        std::string GetValue(const char* parameterName, const char* initial = nullptr) const;
        int         GetInteger(const char* parameterName) const;
        std::uint64_t GetULong(const char* parameterName) const;
        double      GetReal(const char* parameterName) const;
        bool        GetBool(const char* parameterName) const;

        std::string GetDeviceValue(const char* parameterName) const;
        int         GetDeviceInteger(const char* parameterName) const;
        std::uint64_t GetDeviceULong(const char* parameterName) const;
        double      GetDeviceReal(const char* parameterName) const;
        bool        GetDeviceBool(const char* parameterName) const;
        
        std::string GetChanValue(unsigned chan, const char* parameterName) const;
        int         GetChanInteger(unsigned chan, const char* parameterName) const;
        std::uint64_t GetChanULong(unsigned chan, const char* parameterName) const;
        double      GetChanReal(unsigned chan, const char* parameterName) const;
        bool        GetChanBool(unsigned chan, const char* parameterName) const;
        
        std::string GetLVDSValue(unsigned quartet, const char* parameterName) const;
        int         GetLVDSInteger(unsigned quartet, const char* parameterName) const;
        std::uint64_t GetLVDSULong(unsigned quartet, const char* parameterName) const;
        std::uint64_t GetLVDSTriggerMask(unsigned maskNo) const;
        
        void Command(const char* command) const;
        
        void SetActiveEndpoint(const char* ep) const;
        std::string GetActiveEndpoint() const;
        void SetReadDataFormat(const char* json) const;
                
        bool ReadData(int timeout, int argc, void** argv) const;
        bool hasData() const;
    };
}

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        <classname>Dig2Device</classname> provides low level
                        access to the the device, channel and LVDS parameter spaces
                        of a CAEN nextgen digitizer.  For parameter setting
                        methods, method overloading provides the appearance of
                        a single method, while, since C++ does not support overloading
                        that is based solely on  the return type, there are separate
                        parameter getters for each possible parameter type.
                      </para>
                      <para>
                        Addditionally, digitizer commands, endpoint selection,
                        testing for data presence and data acquisition are
                        supported at a low level.
                      </para>
                      <para>
                        Note that if the class is built with the preprocessor
                        variable <literal>ENABLE_TRACING</literal> defined
                        and <function>caen_nscldaq::set_tracing</function>
                        is called with a <literal>true</literal> parameter,
                        all interactions with the CAEN support library will
                        be logged to the file <filename>Dig2Device.log</filename>.
                        This causes a huge performance hit but is useful
                        in sending information to CAEN support when questions
                        about digitizer operation arise.
                      </para>
                </refsect1>
                <refsect1>
                    <title>
                        METHODS and CONSTRUCTION
                    </title>
                    <variablelist>
                        <varlistentry>
                           <term><constructorsynopsis>
                               <methodname> Dig2Device</methodname>
                                <methodparam>
                                    <type>const char*</type><parameter>hostOrPid</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>bool </type><parameter>isUsb </parameter>
                                    <initializer>false</initializer>
                                </methodparam>
                           </constructorsynopsis></term>
                           <listitem>
                               <para>
                                Constructing a <classname>Dig2Device</classname>
                                requires knowing how to connect to the device.
                                There are currently two ways to do so, direct USB
                                connection of via ETHERNET.  The <parameter>hostOrPid</parameter>
                                parameter should be a textual host (dotted IP address
                                e.g. <literal>"10.0.0.2"</literal>)  or the USB
                                PID of the module (there's a sticker on each module
                                with the module's pid e.g. <literal>"15236"</literal>)
                                depending on how you are connecting to the module.
                               </para>
                               <para>
                                The <parameter>isUsb</parameter> parameter, which
                                defaults to <literal>false</literal> should be
                                <literal>true</literal> only if you are connected
                                directly to the module via USB.
                               </para>
                               <para>
                                Note that no DNS translation is attempted on the
                                <parameter>hostOrPid</parameter> parameter if
                                <parameter>isUsb</parameter> is false.  
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetValue</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <methodparam>
                                  <type> T </type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                This  is the core parameter setting method.
                                <parameter>parameterName</parameter> is a full,
                                absolute path to the parameter being set and
                                <parameter>value</parameter> is the value to
                                set the parameter to.  
                               </para>
                               <para>
                                The
                                <type>T</type> data type for <parameter>value</parameter>,
                                in this case indicates that there are several overloads
                                for this method in which T has the type
                                <type>const char*</type>,
                                <type>int</type>,
                                <type>std::uint64_t</type>,
                                <type>double</type>
                                and <type>bool</type>, for the various data types
                                that parameters may take.
                               </para>
                               <para>
                                    Note that the CAEN API requires stringified
                                    versions when setting all of its parameter types,
                                    so the various overloads eventually invoke
                                    the <methodname>SetValue</methodname>
                                    that accept a <type>const char*</type>
                                    vaule.
                                </para>
                               <para>
                                    Errors reported back by the CAEN FELib
                                    are converted to
                                    <classname>std::runtime_error</classname>
                                    exceptions.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetDeviceValue</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>devParName</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>T</type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The parameter space of the CAEN digitizers looks
                                like a file system.  Paths to parameters look like
                                paths to files in that file system.  The
                                <emphasis>directory</emphasis> parts of that path
                                determine the class of the parameter.
                                Device level parameters have a specific and
                                (mostly) consistent path. 
                               </para>
                               <para>
                                This overloaded method (same possible types for
                                <parameter>value</parameter> as <methodname>SetValue</methodname>)
                                computes the path to a device level parameter given the
                                terminal node in the path and invokes
                                <methodname>SetValue</methodname> to set a device
                                level parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetChanValue</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char*</type><parameter> chanParName</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>T</type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                As with device parameters, per channel parameters
                                have paths that are consistently constructed
                                given the parameter name and channel number.
                                This method computes the full path to a per channel
                                parameter and sets that parameter.  It is overloaded
                                int the same manner as <parameter>SetValue</parameter>.
                               </para>
                               <para>
                                Note that the CAEN FELib API actually supports setting
                                more than one per channel parameter to the same
                                value if the channels involved form a contiguous
                                range.  This is not supported in this version of the
                                class.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetLVDSValue</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>quartet</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>LVDSName</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>T </type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The parameters that control the functionality of
                                the front panel LVDS I/O pins is a separate part
                                of the digitizer parameter 'filesystem' parameter
                                space.  This is because the 16 pins are organized into
                                4 pin quartets that can be independently programmed.
                               </para>
                               <para>
                                This overloaded method computes the path
                                to the specified parameter name and quartet and
                                sets that parameter's value.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetLVDSTriggerMask</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>maskNo</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>std::uint64_t </type><parameter>mask</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                With apologies to my colleagues at CAEN>  THe
                                handling of the LVDS trigger mask is just totally
                                inconsistent with the manner in which all other
                                parameters in the digitizer are handled.
                                They therefore merit a separate method to set
                                their values.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                              <methodsynopsis>
                                 <type>std::string </type>
                                 <methodname>GetValue</methodname>
                                 <methodparam>
                                     <type>const char* </type><parameter>parameterName</parameter>
                                 </methodparam>
                                 <methodparam>
                                     <type>const char* </type><parameter>initial</parameter>
                                    <initializer>nullptr</initializer>
                                 </methodparam>
                                 <modifier>const</modifier>
                              </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the raw parameter string for a digitizer
                                parameter given its full path.  The
                                <parameter>initial</parameter> parameter has to do
                                with the wonky manner in which LVDS trigger masks
                                must be set.  Ignore and use
                                <methodname>GetLVDSTriggerMask</methodname> to
                                retrieve those trigger masks and it will take care
                                handling that wonkiness transparently.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int         </type>
                              <methodname>GetInteger</methodname>
                              <methodparam>
                                  <type>const char*</type><parameter> parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Invokes <methodname>GetValue</methodname> and
                                attempts to conver the resulting string to
                                an integer which is then returned.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>GetULong</methodname>
                              <methodparam>
                                  <type>const char*</type><parameter> parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetValue</methodname>, converts
                                the returned string to a <type>std::uint64_t</type>
                                and returns the converted value.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double      </type>
                              <methodname>GetReal</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetValue</methodname> and converts
                                the result to a <type>double</type>
                                which is returned.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool </type>
                              <methodname>GetBool</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetValue</methodname> and
                                converts the returned value to a boolean
                                which is returned.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string </type>
                              <methodname>GetDeviceValue</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Computes the full path to the device level parameter
                                <parameter>parameterName</parameter> and
                                returns
                                the value <methodname>GetValue</methodname>
                                returns for that path.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int         </type>
                              <methodname>GetDeviceInteger</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetDeviceValue</methodname>
                                but calls <methodname>GetInteger</methodname>
                                with the computed full path.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>td::uint64_t </type>
                              <methodname>GetDeviceULong</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier> const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetUlong</methodname> with
                                the computed full path to the parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double      </type>
                              <methodname>GetDeviceReal</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier> const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetReal</methodname> with the
                                fully computed path to <parameter>parameterName</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool        </type>
                              <methodname>GetDeviceBool</methodname>
                              <methodparam>
                                  <type>const char*</type><parameter> parameterName</parameter>
                              </methodparam>
                              <modifier>
                                const
                              </modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>getBool</methodname> with the
                                full computed path for <parameter>parameterName</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string </type>
                              <methodname>GetChanValue</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Computes the full path to
                                the channel level parameter;
                                <parameter>parameterName</parameter> for
                                channel <parameter>chan</parameter> and
                                returns the value for
                                <methodname>getValue</methodname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int         </type>
                              <methodname>GetChanInteger</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>getChanValue</methodname>
                                but returns the value of <methodname>GetInteger</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>GetChanULong</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetChanValue</methodname>
                                but returns the value of <methodname>GetUlong</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double      </type>
                              <methodname>GetChanReal</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char*</type><parameter> parameterName</parameter>
                              </methodparam>
                              <modifier>
                                const
                              </modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetChanValue</methodname>
                                but returns the result of <methodname>GetReal</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool        </type>
                              <methodname>GetChanBool</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as
                                <methodname>GetChanValue</methodname> but returns
                                the results of <methodname>GetBool</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string </type>
                              <methodname>GetLVDSValue</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>quartet</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Retrieves the value of the LVDS configuration
                                parameter; <parameter>parameterName</parameter>
                                for the selected
                                <parameter>quartet</parameter> of pins.
                                This computes the full path to that parameter
                                and invokes <methodname>GetValue</methodname>
                                to get the result.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int </type>
                              <methodname>GetLVDSInteger</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>quartet</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetLVDSValue</methodname>
                                but uses <methodname>GetInteger</methodname>
                                to retrive the result.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>GetLVDSUlong</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>quartet</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetLVDSValue</methodname>
                                but uses <methodname>GetULong</methodname>
                                to retrive the result.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>GetLVDSTriggerMask</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>maskNo</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                See my rather acerbit note about LVS trigger masks
                                in <methodname>SetLVDSTriggerMask</methodname>.
                                This returns the value of LVDS trigger mask
                                <parameter>maskNo</parameter>.  That is the
                                mask to be applied to pin
                                <parameter>maskNo</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>Command</methodname>
                              <methodparam>
                                  <type>const char*</type><parameter> command</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sends the command specified by
                                <parameter>command</parameter> to the digitizer.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetActiveEndpoint</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>ep</parameter>
                              </methodparam>
                              <modifier> const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Digitizers have several endpoints from which data
                                can be acquired.  In order to acquire data
                                from an endpoint the end point must be made
                                active and its data format configured
                                (see <methodname>SetReadDataFormat</methodname>).
                                Once this is  done, <methodname>hasData</methodname>
                                and <methodname>ReadData</methodname> will,
                                respectively, check for data on the active endpoint
                                and read data from it.
                               </para>
                               <para>
                                The set of endpoints exported by a digitizer
                                depend on the firmware that it is running.
                               </para>
                               <para>
                                This method selects the active endpoint
                                via its name: <parameter>ep</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type> std::string </type>
                              <methodname>GetActiveEndpoint</methodname>
                              <void />
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the name of the currently active
                                digitizer endpoint.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetReadDataFormat</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>json</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Each endpoint can, on a read, return a number of
                                parameters, at the client's discretion.
                                The parameters desired and the order in which
                                they are desired is determined by a JSON
                                (JavaScript Object Notation) string that is passed
                                as <parameter>json</parameter> to  this method.
                               </para>
                               <para>
                                The method determines what is returned by
                                <methodname>ReadData</methodname> for the active
                                endpoint.  It also, implicitly detemrines the
                                number and type of parameters to be passed to
                                <methodname>ReadData</methodname>.
                               </para>
                               <para>
                                The specific set of parameters and each parameter
                                type depends on the firmware running in the digitizer
                                and the current endpoint.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool</type>
                              <methodname>ReadData</methodname>
                              <methodparam>
                                  <type>int</type><parameter>timeout</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>int </type><parameter>argc</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>void** </type><parameter>argv</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Attempts to read data from the active endpoint.
                                If no data is available within
                                <parameter>timeout</parameter> millisconds of
                                initiating the read, the method returns
                                <literal>false</literal>,  If data is available,
                                then the method returns <literal>true</literal>
                               </para>
                               <para>
                                <parameter>argc</parameter> is the number of
                                parameters in the argument array <parameter>argv</parameter>.
                                <parameter>argv</parameter>, in general is an
                                array of pointers to buffers for the items
                                sequentially requested in the JSON passed to
                                <methodname>SetReadDataFormat</methodname>
                                for the active endpoint.  The data types to
                                which the pointers point, again, is determined
                                by the JSON passed to the endpoint.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool</type>
                              <methodname>hasData</methodname>
                              <void />
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns <literal>true</literal> if the digitizer
                                has data on the currently selected endpoint
                                or <literal>false</literal> if not.
                                This returns immediately either way.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>VX2750Pha</refentrytitle>
                  <manvolnum>3daq</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>VX2750Pha</refname>
                  <refpurpose>Provide compile time checked API to CAEN Nextgen digitizers DPP-PHA</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;VX2750Pha.h&gt;

namespace caen_nscldaq {

class VX2750Pha : public Dig2Device
{
public:
    VX2750Pha(const char* hostOrPid, bool isUsb = false);
    
    
    std::string  getCupVersion() const;     // Get the CUP version
    std::string  getFpgaFWVersion() const;  // Get the firmware Version
    FwType       getFirmwareType() const;   // Get the type of the firmware.
    std::string  getModelCode() const;
    std::string  getPiggyBackCode() const;
    std::string  getModelName() const;
    FormFactor   getFormFactor() const;
    int          getFamilyCode() const;
    std::string  getSerialNumber() const;
    int          getMotherboardRev() const;
    int          getPiggybackRev() const;
    std::string  getLicense() const;
    bool         isLicensed() const;
    int          remainingUnlicensedTime() const;
    int          channelCount() const;
    int          bitsOfResolution() const;
    int          sampleRate() const;
    int          inputRange() const;
    bool         isDifferentialInput() const;
    int          inputImpedance() const;
    int          ipAddress() const;
    int          netMask() const;
    int          gateway() const;
    ClockSource  getClockSource() const;
    void         setClockSource(ClockSource) const;
    bool         isClockOutOnP0() const;
    void         setClockOutOnP0(bool state) const;
    bool         isClockOutOnFP() const;
    void         setClockOutOnFP(bool state) const;
    std::vector&lt;StartSource&gt;  getStartSource() const;
    void         setStartSource(const std::vector&lt;StartSource&gt;&amp; src) const;
    std::vector&lt;GlobalTriggerSource&gt; getGlobalTriggerSource() const;
    void         setGlobalTriggerSource(const std::vector&lt;GlobalTriggerSource&gt;&amp; sources) const;
    std::vector&lt;WaveTriggerSource&gt; getWaveTriggerSource(unsigned ch) const;
    void         setWaveTriggerSource(unsigned ch, const std::vector&lt;WaveTriggerSource&gt;&amp; src) const;
    std::vector&lt;EventTriggerSource&gt; getEventTriggerSource(unsigned ch) const;
    void         setEventTriggerSource(unsigned ch, const std::vector&lt;EventTriggerSource&gt;&amp; src) const;
    
    std::uint64_t getChannelTriggerMask(unsigned ch) const;
    void          setChannelTriggerMask(unsigned ch, std::uint64_t mask) const;
    TraceRecordMode getTraceRecordMode(unsigned ch) const;
    void           setTraceRecordMode(unsigned ch, TraceRecordMode mode) const;
    TRGOUTMode    getTRGOUTMode() const;
    void          setTRGOUTMode(TRGOUTMode mode) const;
    GPIOMode      getGPIOMode() const;
    void          setGPIOMode(GPIOMode mode) const;
    BusyInSource   getBusyInputSource() const;
    void          setBusyInputSource(BusyInSource src) const;
    SyncOutMode   getSyncOutMode() const;
    void          setSyncOutMode(SyncOutMode mode) const;
    VetoSource    getBoardVetoSource() const;
    void          setBoardVetoSource(VetoSource src) const;
    std::uint64_t   getBoardVetoWidth() const;
    void          setBoardVetoWidth(std::uint64_t ns) const;
    VetoPolarity  getBoardVetoPolarity() const;
    void          setBoardVetoPolarity(VetoPolarity pol) const;
    ChannelVetoSource getChannelVetoSource(unsigned chan) const;
    void          setChannelVetoSource(unsigned chan, ChannelVetoSource src) const;
    std::uint32_t getChannelVetoWidth(unsigned chan) const;
    void          setChannelVetoWidth(unsigned chan, std::uint32_t ns) const;
    std::uint32_t getRunDelay() const;
    void          setRunDelay(std::uint32_t ns) const;
    bool          isAutoDisarmEnabled() const;
    void          setAutoDisarmEnabled(bool state) const;
    std::uint32_t      getLEDStatus() const;
    std::uint32_t      getAcquisitionStatus() const;
    std::uint32_t      getMaxRawDataSize() const;
    double        getVolatileClockDelay() const;
    void          setVolatileClockDelay(double value) const;
    double        getPermanentClockDelay() const;
    void          setPermanentClockDelay(double value) const;
    WaveDataSource getWaveDataSource(unsigned chan) const;
    void          setWaveDataSource(unsigned chan, WaveDataSource source) const;
    std::uint32_t getRecordSamples(unsigned chan) const;
    void          setRecordSamples(unsigned chan, std::uint32_t samples) const;
    std::uint32_t getRecordNs(unsigned chan) const;
    void          setRecordNs(unsigned chan, std::uint32_t ns) const;
    WaveResolution getWaveResolution(unsigned chan) const;
    void          setWaveResolution(unsigned chan, WaveResolution resolution) const;
    AnalogProbe   getAnalogProbe(unsigned chan, unsigned probeNum) const;
    void          setAnalogProbe(unsigned chan, unsigned probeNum, AnalogProbe probe) const;
    DigitalProbe  getDigitalProbe(unsigned chan, unsigned probeNum) const;
    void          setDigitalProbe(
        unsigned chan, unsigned probeNum, DigitalProbe probe
    ) const;
    std::uint32_t getPreTriggerSamples(unsigned chan) const;
    void          setPreTriggerSamples(unsigned chan, std::uint32_t nsamples) const;
    std::uint32_t getPreTriggerNs(unsigned chan) const;
    void          setPreTriggerNs(unsigned chan, std::uint32_t ns) const;
    std::uint64_t getTestPulsePeriod() const;
    void          setTestPulsePeriod(std::uint64_t ns) const;
    std::uint64_t getTestPulseWidth() const;
    void          setTestPulseWidth(std::uint64_t ns) const;
    std::uint32_t getTestPulseLowLevel() const;
    void          setTestPulseLowLevel(std::uint32_t counts) const;
    std::uint32_t getTestPulseHighLevel() const;
    void          setTestPulseHighLevel(std::uint32_t counts) const;
    IOLevel       getIOLevel() const;
    void          setIOLevel(IOLevel level) const;
    double        getAirInTemp() const;
    double        getAirOutTemp() const;
    double        getCoreTemp() const;
    double        getFirstADCTemp() const;         
    double        getLastADCTemp() const;
    double        getHottestADCTemp() const;
    double        getADCTemp(unsigned chip) const;
    double        getDCDCConverterTemp() const;
    double        getDCDCConverterInputVoltage() const;
    double        getDCDCConverterOutputVoltage() const;
    double        getDCDCConverterAmps() const;
    double        getDCDCConverterHz() const;
    double        getDCDCConverterDutyCycle() const;
    std::uint32_t getFanSpeed(unsigned fan) const;
    std::uint32_t getErrorFlagMask() const;
    void          setErrorFlagMask(std::uint32_t mask) const;
    std::uint32_t getErrorFlagDataMask() const;
    void          setErrorFlagDataMask(std::uint32_t mask) const;
    std::uint32_t getErrorFlags() const;
    bool          isBoardReady() const;
    IndividualTriggerLogic getITLAMainLogic() const;
    IndividualTriggerLogic getITLBMainLogic() const;
    void          setITLAMainLogic(IndividualTriggerLogic sel) const;
    void          setITLBMainLogic(IndividualTriggerLogic sel) const;
    unsigned      getITLAMajorityLevel() const;
    unsigned      getITLBMajorityLevel() const;
    void          setITLAMajorityLevel(unsigned level) const;
    void          setITLBMajorityLevel(unsigned level) const;
    PairTriggerLogic getITLAPairLogic() const;
    PairTriggerLogic getITLBPairLogic() const;
    void         setITLAPairLogic(PairTriggerLogic sel) const;
    void         setITLBPairLogic(PairTriggerLogic sel) const;
    bool          isITLAInverted() const;
    bool          isITLBInverted() const;
    void          setITLAInverted(bool invert) const;
    void          setITLBInverted(bool invert) const;
    ITLConnect    getITLConnect(unsigned ch) const;
    void          setITLConnect(unsigned ch, ITLConnect selection) const;
    
    std::uint64_t getITLAMask() const;
    std::uint64_t getITLBMask() const;
    void          setITLAMask(std::uint64_t mask) const;
    void          setITLBMask(std::uint64_t mask) const;
    
    std::uint32_t getITLAGateWidth() const;
    std::uint32_t getITLBGateWidth() const;
    void          setITLAGateWidth(std::uint32_t ns) const;
    void          setITLBGateWidth(std::uint32_t ns) const;
    
    LVDSMode      getLVDSMode(unsigned quartet) const;
    void          setLVDSMode(unsigned quartet, LVDSMode mode) const;
    LVDSDirection getLVDSDirection(unsigned quartet) const;
    void          setLVDSDirection(unsigned quartet, LVDSDirection direction) const;
    std::uint16_t getLVDSIOReg() const;
    void          setLVDSIOReg(std::uint16_t mask) const;
    std::uint64_t getLVDSTriggerMask(unsigned inputNum) const;
    void          setLVDSTriggerMask(unsigned inputNum, std::uint64_t mask) const;  
    void setDACOutMode(DACOutputMode mode) const;
    DACOutputMode getDACOutMode() const;
    std::uint16_t getDACOutValue() const;
    void          setDACOutValue(std::uint16_t value) const;
    unsigned      getDACChannel() const;
    void          setDACChannel(unsigned chan) const;
    double        getVGAGain(unsigned group) const;
    void          setVGAGain(unsigned group, double value) const;
    bool          isOffsetCalibrationEnabled() const;
    void          enableOffsetCalibration(bool enable) const;
    bool          isChannelEnabled(unsigned chan) const;
    void          enableChannel(unsigned chan, bool enable) const;
    int           getSelfTriggerRate(unsigned chan) const;
    std::uint32_t getChannelStatus(unsigned chan) const;
    double        getDCOffset(unsigned chan) const;
    void          setDCOffset(unsigned chan, double pct) const;
    double        getGainFactor(unsigned chan) const;
    std::uint32_t getTriggerThreshold(unsigned chan) const;
    void          setTriggerThreshold(unsigned chan, std::uint32_t threshold) const;
    Polarity      getPulsePolarity(unsigned chan) const;
    void          setPulsePolarity(unsigned chan, Polarity pol) const;
    std::uint16_t getEnergySkimLowDiscriminator(unsigned chan) const;
    void          setEnergySkimLowDiscriminator(unsigned chan, std::uint16_t value) const;
    std::uint16_t getEnergySkimHighDiscriminator(unsigned chan) const;
    void          setEnergySkimHighDiscriminator(unsigned chan, std::uint16_t value) const;
    EventSelection getEventSelector(unsigned chan) const;
    void           setEventSelector(unsigned chan, EventSelection sel) const;
    EventSelection getWaveformSelector(unsigned chan) const;
    void           setWaveformSelector(unsigned chan, EventSelection sel) const;
    CoincidenceMask getCoincidenceMask(unsigned chan) const;
    void           setCoincidenceMask(unsigned chan, CoincidenceMask sel) const;
    CoincidenceMask getAntiCoincidenceMask(unsigned chan) const;
    void           setAntiCoincidenceMask(unsigned chan, CoincidenceMask sel) const;
    std::uint32_t  getCoincidenceSamples(unsigned chan) const;
    void           setCoincidenceSamples(unsigned chan, std::uint32_t samples) const;
    std::uint32_t  getCoincidenceNs(unsigned chan) const;
    void           setCoincidenceNs(unsigned chan, std::uint32_t ns) const;
    std::uint32_t  getTimeFilterRiseTime(unsigned chan) const;
    std::uint32_t  getTimeFilterRiseSamples(unsigned chan) const;
    void           setTimeFilterRiseTime(unsigned chan, std::uint32_t ns) const;
    void           setTimeFilterRiseSamples(unsigned chan, std::uint32_t samples) const;
    std::uint32_t  getTimeFilterRetriggerGuardTime(unsigned chan) const;
    std::uint32_t  getTimeFilterRetriggerGuardSamples(unsigned chan) const;
    void           setTimeFilterRetriggerGuardTime(unsigned chan, std::uint32_t ns) const;
    void           setTimeFilterRetriggerGuardSamples(unsigned chan, std::uint32_t samples) const;
    std::uint32_t  getEnergyFilterRiseTime(unsigned chan) const;
    std::uint32_t  getEnergyFilterRiseSamples(unsigned chan) const;
    void           setEnergyFilterRiseTime(unsigned chan, std::uint32_t ns) const;
    void           setEnergyFilterRiseSamples(unsigned chan, std::uint32_t samples) const;
    std::uint32_t  getEnergyFilterFlatTopTime(unsigned chan) const;
    std::uint32_t  getEnergyFilterFlatTopSamples(unsigned chan) const;
    void           setEnergyFilterFlatTopTime(unsigned chan, std::uint32_t ns) const;
    void           setEnergyFilterFlatTopSamples(unsigned chan, std::uint32_t samples) const;
    std::uint32_t  getEnergyFilterPeakingPosition(unsigned chan) const;
    void           setEnergyFilterPeakingPosition(unsigned chan, std::uint32_t pct) const;
    EnergyPeakingAverage getEnergyFilterPeakingAverage(unsigned chan) const;
    void          setEnergyFilterPeakingAverage(unsigned chan, EnergyPeakingAverage sel) const;
    std::uint32_t getEnergyFilterPoleZeroTime(unsigned chan) const;
    std::uint32_t getEnergyFilterPoleZeroSamples(unsigned chan) const;
    void          setEnergyFilterPoleZeroTime(unsigned chan, std::uint32_t ns) const;
    void          setEnergyFilterPoleZeroSamples(unsigned chan, std::uint32_t samples) const;
    double        getEnergyFilterFineGain(unsigned chan) const;
    void          setEnergyFilterFineGain(unsigned chan, double gain) const;
    bool          isEnergyFilterFLimitationEnabled(unsigned chan) const;
    void          enableEnergyFilterFLimitation(unsigned chan, bool enable) const;
    EnergyFilterBaselineAverage getEnergyFilterBaselineAverage(unsigned chan) const;
    void          setEnergyFilterBaselineAverage(unsigned chan, EnergyFilterBaselineAverage sel) const;
    std::uint32_t getEnergyFilterBaselineGuardTime(unsigned chan) const;
    std::uint32_t getEnergyFilterBaselineGuardSamples(unsigned chan) const;
    void          setEnergyFilterBaselineGuardTime(unsigned chan, std::uint32_t ns) const;
    void          setEnergyFilterBaselineGuardSamples(unsigned chan, std::uint32_t samples) const;
    std::uint32_t getEnergyFilterPileupGuardTime(unsigned chan) const;
    std::uint32_t getEnergyFilterPileupGuardSamples(unsigned chan) const;
    void          setEnergyFilterPileupGuardTime(unsigned chan, std::uint32_t ns) const;
    void          setEnergyFilterPileupGuardSamples(unsigned chan, std::uint32_t samples) const;
    std::uint8_t  getEnergyBits(unsigned chan) const;
    std::uint64_t getRealtime(unsigned chan) const;
    std::uint64_t getDeadtime(unsigned chan) const;
    void          Reset();
    void          Clear();
    void          Arm();
    void          Disarm();
    void          Start();
    void          Stop();
    void          Trigger();
    void          ReloadCalibration();
    Endpoint      getEndpoint();
    void          selectEndpoint(Endpoint selection);
    
    void   initializeRawEndpoint();         
    size_t readRawEndpoint(void* pBuffer);
    void setDefaultFormat();
    void enableRawTimestamp(bool enable);
    void enableFineTimestamp(bool enable);
    void enableFlags(bool enable);
    void enableDownsampling(bool enable);
    void enableAnalogProbes(bool probe1, bool probe2);
    void enableDigitalProbes(bool probe1, bool probe2, bool probe3, bool probe4);
    void enableSampleSize(bool enable);
    void enableRawEventSize(bool enable);
    
    void initializeDPPPHAReadout();
    void readDPPPHAEndpoint(DecodedEvent&amp; event);
    
    void initDecodedBuffer(DecodedEvent&amp; event);
    void setupDecodedBuffer(DecodedEvent&amp; event);
    void freeDecodedBuffer(DecodedEvent&amp; event);
    
    
   };
}
                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This class provides a generic API, with parameter values
                        validated at compile time, to CAEN nextgen digitizers
                        running DPP-PHA mode.  Caller error risk is mitigated
                        several ways:
                      </para>
                      <itemizedlist>
                        <listitem>
                           <para>
                              Enums and symbolic constants are used to avoid
                              sending bad textual parameters to the digitizer.
                              Maps are used to translate betweenthe parameter
                              and the strings and back.  Extensive unit tests
                              have validated these maps with the digitizer
                              hardware itself.
                           </para>
                        </listitem>
                        <listitem>
                           <para>
                              The generation of JSON to specify the data format
                              request has been hidden behind a struct that
                              describes the desired items.
                           </para>
                        </listitem>
                        <listitem>
                           <para>
                              The set of pointers and what they point to have
                              been abstracted from the read data method in order
                              providing a read into a data structure that has a
                              fixed layout but might be missing some items
                              depending on the requests.
                           </para>
                        </listitem>
                        <listitem>
                           <para>
                               Command strings are hidden behind individual
                               methods for each command understood by the
                               digitizer.
                           </para>
                        </listitem>
                      </itemizedlist>
                      <para>
                        Note that this class is derived from
                        <classname>caen_nscldaq::Dig2Device</classname>
                        which means that any of the methods of that
                        class can be called directly if the services of this
                        class fall short of the application needs.
                      </para>
                </refsect1>
                <refsect1>
                    <title>METHODS CONSTRUCTORS AND DATA TYPES</title>
                    <para>
                        The data structures exported by this class are described
                        by the first method that uses them rather than
                        providing a separate data structures section to this
                        manpage.
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term><constructorsynopsis>
                               <methodname>VX2750Pha</methodname>
                                <methodparam>
                                    <type>const char* </type><parameter>hostOrPid</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>bool </type><parameter>isUsb </parameter>
                                    <initializer>false</initializer>
                                </methodparam>
                           </constructorsynopsis></term>
                           <listitem>
                               <para>
                                See the constructor of
                                <classname>caen_nscldaq::Dig2Device</classname>
                                for the meaning of theses parameters, which
                                describe how to form a connection with the
                                digitizer.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string  </type>
                              <methodname>getCupVersion</methodname>
                              <void />
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the version string of the CUP firmware
                                file running in the digitizer.  This is of
                                the form yyyymmddnn where <literal>nn</literal>
                                is a sequence number starting from 00 in case
                                more than one firmware file was
                                rolled in that day.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string  </type>
                              <methodname>getFpgaFWVersion</methodname>
                              <void />
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns a string that identifies the firmware
                                loaded in the FPGA of the digitizer.  The
                                format of this string is not documented.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>FwType       </type>
                              <methodname>getFirmwareType</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the type of firmware currently running
                                in the digitizer.   The firmware type is returned
                                as an enumerated type
                                <type>caen_nscldaq::VX2750Pha::FWType</type> which
                                can have the values:
                               </para>
                               <itemizedlist>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::DPP_PHA</literal>  - pulse height
                                      anaysis firmware.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::DPP_ZLE</literal>  - wave forms in
                                      run length encoding compression format.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::DPP_PSD</literal> - Pulse shape discrimination
                                      firmware.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::DPP_DAW</literal>  - Dynamic acquisition
                                      window wave form capture firmware.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::DPP_OPEN</literal>  - User written
                                      firmware (Open FPGA).
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::Scope </literal> - Raw waveform
                                      capture (Oscilloscope mode).
                                   </para>
                                </listitem>
                                </itemizedlist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string  </type>
                              <methodname>getModelCode</methodname>
                              <void />
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the model code string e.g.
                                <literal>WV2740XAAAAA.</literal>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string  </type>
                              <methodname>getPiggyBackCode</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the CAEN daugherboard type string e.g.
                                <literal>WA40BXAAAAAA</literal>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string  </type>
                              <methodname>getModelName</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the digitizer model string e.g.
                                <literal>V2740</literal>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>FormFactor   </type>
                              <methodname>getFormFactor</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns a
                                <type>caen_nscldaq::VX2750Pha::FormFactor</type>
                                enumerated value that represents the device
                                formfactor.  This can have values
                               </para>
                               <itemizedlist>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::VME</literal>
                                      VME module
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::VME64X</literal>
                                      VME module compatible with the VME64X standard.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::DT</literal>
                                      Desktop format.
                                   </para>
                                </listitem>
                               </itemizedlist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int  </type>
                              <methodname>getFamilyCode</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the digitizer family code.  This is an
                                interger that is the family order number
                                 e.g. a <literal>vx2740</literal> will return
                                 <literal>2740</literal> for this function.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string  </type>
                              <methodname>getSerialNumber()</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the digitizer's serial number string.
                                Note that at present, serial numbers are
                                integers, but the API documents this as returning
                                a string so a string is what we return.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>getMotherboardRev</methodname>
                              <void /> <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the motherboard revision level.  This is
                                the revision level of the circuit board.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>getPiggybackRev</methodname>
                              <void /> <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the revision of the daughter board's
                                printed circuit board.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string  </type>
                              <methodname>getLicense</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the product unlock code for the firmware
                                being run.   This is instance specific.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool        </type>
                              <methodname> isLicensed</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns <literal>true</literal> if the firmware
                                product is unlocked.   <literal>false</literal>
                                if the product firmware is running in trial (time-bomb)
                                mode.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>remainingUnlicensedTime</methodname>
                              <void /> <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                If <methodname>isLicensed</methodname>
                                returned <literal>false</literal>, this is the
                                number of seconds remaining before the digitizer
                                goes catatonic (trial mode expiry).  Once that
                                happens, the digitizer must be rebooted (e.g.
                                power cycled).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>channelCount</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the number of channels the digitizer has.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>bitsOfResolution</methodname>
                             <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the number of bits of ADC resolution.
                                This  is the number of bits in the FADC not
                                the resolution of e.g. the extracted pulse height.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>sampleRate</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the FADC sampling rate in MHz.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>inputRange</methodname>
                              <void /> <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the input range in VPP.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool  </type>
                              <methodname>isDifferentialInput</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns <literal>true</literal> if the input
                                is differential and <literal>false</literal>
                                if single ended.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>inputImpedance</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the module input impedance in Ohms.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>ipAddress</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the IP address of the module in
                              host byte order.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>netMask</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the netmask for the module's NIC in
                                host byte order.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int   </type>
                              <methodname>gateway</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the gateway address for the module in
                                host byte order.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>ClockSource  </type>
                              <methodname>getClockSource</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the clock source selected.  This is an
                                enumerated type:
                                <type>caen_nscldaq::VX2750Pha::ClockSource</type>
                                which can have the values:
                                <itemizedlist>
                                    <listitem>
                                       <para>
                                          <literal>caen_nscldaq::VX2750Pha::Internal</literal>
                                          Internal 62.5MHz oscillator.
                                       </para>
                                    </listitem>
                                    <listitem>
                                       <para>
                                          <literal>caen_nscldaq::VX2750Pha::FrontPanel</literal>
                                          Front panel CLK IN.
                                       </para>
                                    </listitem>
                                    <listitem>
                                       <para>
                                          <literal>caen_nscldaq::VX2750Pha::Clock_P0</literal>
                                          P0 VME backplane connnector (not implemented)
                                       </para>
                                    </listitem>
                                    <listitem>
                                       <para>
                                          <literal>caen_nscldaq::VX2750Pha::Link</literal> Regenerated from
                                          the Ethernet (not implemented) (WR?).
                                       </para>
                                    </listitem>
                                    <listitem>
                                       <para>
                                          <literal>caen_nscldaq::VX2750Pha::DIPSelected</literal>
                                          Clock source selected by DIP switches
                                          on the circuit board (not implemented).
                                       </para>
                                    </listitem>
                                </itemizedlist>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void   </type>
                              <methodname>setClockSource</methodname>
                              <methodparam>
                                  <type>ClockSource </type><parameter>src</parameter>
                              </methodparam>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Selects the clock source.  Values are described in
                                <methodname>getClockSource</methodname>.
                                Note that using an unimplemented value will
                                result in an error (exception) being thrown.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool  </type>
                              <methodname>isClockOutOnP0</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return <literal>true</literal>
                                if the clock has been enabled to
                                be output on the P0 VME connector.
                                <literal>false</literal> if not.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setClockOutOnP0</methodname>
                              <methodparam>
                                  <type>bool </type><parameter>state</parameter>
                              </methodparam>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                If <parameter>state</parameter> is
                                <literal>true</literal> the clock will be
                                enabled to be output on the P0 connector.
                                Otherwise, not.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool  </type>
                              <methodname>isClockOutOnFP</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returne <literal>true</literal> if the
                                clock is enabled to be output on the CLK OUT
                                front panel connector (for the clock
                                daisy chain).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setClockOutOnFP</methodname>
                              <methodparam>
                                  <type>bool </type><parameter>state</parameter>
                              </methodparam>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                If <parameter>state</parameter> is
                                <literal>true</literal>, the module clock source
                                will be echoed to the CLK OUT front panel
                                connector.  This is the most common way to
                                run the modules synchronized with a common
                                clock/timestamp.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::vector&lt;StartSource&gt; </type>
                              <methodname>getStartSource</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The module may have several start sources enabled.
                                The start source is what actually determines
                                both, when the module starts taking data, and the
                                timestamp zero of the clock.  Getting the
                                start source right is an essential part of running
                                serveral modules with a synchronized time stamp.
                               </para>
                               <para>
                                Several start sources may be selected
                                (see <methodname>setStartSource</methodname> below).
                                The return value is a vector whose members
                                include all selected start sources.
                                The members of the vector are of enumerated type:
                                <type>caen_nscldaq::VX2750Pha::StartSource</type>
                                Which can have any of the values:
                                <literal>caen_nscldaq::VX2750Pha::Start_EncodedClockIn</literal>,
                                <literal>caen_nscldaq::VX2750Pha::SIN_Level</literal>,
                                <literal>caen_nscldaq::VX2750Pha::SIN_Edge</literal>,
                                <literal>caen_nscldaq::VX2750Pha::SWCommand</literal>,
                                <literal>caen_nscldaq::VX2750Pha::Start_LVDS</literal>,
                                or <literal>caen_nscldaq::VX2750Pha::Start_P0</literal>.
                                
                               </para>
                               <para>
                                    One way to get synchronized operation is to
                                    program all but the master module to start
                                    on <literal>SIN_Edget</literal>, program
                                    the master module to start on <literal>SWCommand</literal>,
                                    program the GPIO to be <literal>GPIO_Run</literal>
                                    for all modules and make a daisy chain of GPIO -> SIN
                                    from the master down the chain of modules.
                                    In this way, whent he master is given the software
                                    start, it's run will propagate as the SIN to all
                                    modules in the chain.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setStartSource</methodname>
                              <methodparam>
                                  <type>const std::vector&lt;StartSource&gt;&amp;</type><parameter> src</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Progams the module's start sources.  See
                                <methodname>getStartSource</methodname>.
                                <parameter>src</parameter> references a vector
                                that contains all of the desired start sources
                                for the module.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::vector&lt;GlobalTriggerSource&gt;</type>
                              <methodname>getGlobalTriggerSource</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The module can have several global trigger sources.
                                This method returns a vector whose members
                                are the selected global trigger sources.
                                See <methodname>setGlobalTriggerSource</methodname>.
                               </para>
                               <para>
                                Each element of the returned vector is of type
                                <type>caen_nscldaq::VX2750Pha::GlobalTriggerSource</type>.
                                This is an enumerated type that can be one of:
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_TriggerIn</literal>,
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_P0</literal>,
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_Software</literal>,
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_LVDS</literal>,
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_InternalA</literal>,
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_InternalB</literal>
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_InternalAandB</literal>,
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_InternalAorB</literal>,
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_EncodedClkIn</literal>,
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_GPIO</literal>,
                                or
                                <literal>caen_nscldaq::VX2750Pha::GlobalTrigger_TestPulse</literal>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setGlobalTriggerSource</methodname>
                              <methodparam>
                                  <type>const std::vector&lt;GlobalTriggerSource&gt;&amp;</type><parameter> sources</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The board can accept several global trigger sources,
                                see <methodname>getGlobalGriggerSource</methodname>.
                                This method selects the global trigger sources
                                the board recognizes.  The <parameter>sources</parameter>
                                parameter references a vector whose elements are the
                                set of desired global trigger sources.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::vector&lt;WaveTriggerSource&gt;</type>
                              <methodname>getWaveTriggerSource</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>ch</parameter>
                              </methodparam>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The wave trigger source for a channel determines
                                when a channel will produce not only timestamp
                                and energy information but make availalbe (should
                                the readout select it), the waveform.  As with
                                the global trigger, several wave trigger sources
                                can be selected.  The return value is a vector
                                that contains all of the wave trigger sources
                                selected for channel <parameter>ch.</parameter>
                               </para>
                               <para>
                                Elements of the vector are of the enumerated
                                type:
                                <type>caen_nscldaq::VX2750Pha::WaveTriggerSource</type>
                                which can have any of the following values:
                                <literal>caen_nscldaq::VX2750Pha::WaveTrigger_InternalA</literal>,
                                <literal>caen_nscldaq::VX2750Pha::WaveTrigger_InternalB</literal>,
                                <literal>caen_nscldaq::VX2750Pha::WaveTrigger_GlobalTriggerSource</literal>,
                                <literal>caen_nscldaq::VX2750Pha::WaveTrigger_TRGIN</literal>,
                                <literal>caen_nscldaq::VX2750Pha::ExternalInhibit</literal>,
                                <literal>caen_nscldaq::VX2750Pha::ADCUnderSaturation</literal>,
                                <literal>caen_nscldaq::VX2750Pha::ADCOverSaturation</literal>,
                                <literal>caen_nscldaq::VX2750Pha::WaveTrigger_Software</literal>,
                                <literal>caen_nscldaq::VX2750Pha::WaveTrigger_ChannelSelfTrigger</literal>,
                                <literal>caen_nscldaq::VX2750Pha::WaveTrigger_AnyChannelSelfTrigger</literal>,
                                or
                                <literal>caen_nscldaq::VX2750Pha::WaveTrigger_Disabled</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setWaveTriggerSource</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>ch</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const std::vector&lt;WaveTriggerSource&gt;&amp; </type><parameter>src</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the desired wave trigger sources for
                                channel <parameter>ch</parameter> to the
                                sources in the vector
                                <parameter>src</parameter>.  See
                                <methodname>getWaveTriggerSource</methodname>
                                for a description of the
                                <type>caen_nscldaq:VX2750Pha::WaveTriggerSource</type>
                                data type.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::vector&lt;EventTriggerSource&gt;</type>
                              <methodname> getEventTriggerSource</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>ch</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The event trigger source for a channel determines when
                                the digitizer sends only the energy and timing
                                information for an event.  Several  event
                                trigger sources can be specified.
                                The elements of the returned value are the
                                selected event trigger sources.
                               </para>
                               <para>
                                The elements of the returned value are of the
                                enumerated type:
                                <type>caen_nscldaq::VX2750Pha::EventTriggerSource</type>
                                and can have the following values:
                                <literal>caen_nscldaq::VX2750Pha::EventTrigger_InternalA</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EventTrigger_InternalB</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EventTrigger_GlobalTriggerSource</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EventTrigger_TRGIN</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EventTrigger_Software</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EventTrigger_ChannelSelfTrigger</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EventTrigger_AnyChannelSelfTrigger</literal>,
                                or
                                <literal>caen_nscldaq::VX2750Pha::EventTrigger_Disabled</literal>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setEventTriggerSource</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>ch</parameter>
                              </methodparam>
                              <methodparam>
                                   <type>const std::vector&lt;EventTriggerSource&gt;&amp;</type><parameter> src</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the event trigger sources for channel
                                <parameter>ch</parameter> to be the sources that
                                are elements of <parameter>src</parameter>.
                                See <methodname>getEventTriggerSource</methodname>
                                for information about the
                                <type>caen_nscldaq::VX2750Pha::EventTriggerSource</type>
                                data type and the values it can have.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>getChannelTriggerMask</methodname>
                              <methodparam>
                                  <type>unsigned</type><parameter> ch</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the channel trigger mask for
                                channel number <parameter>ch</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type> void </type>
                              <methodname>setChannelTriggerMask</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>ch, </parameter>
                              </methodparam>
                              <methodparam>
                                  <type>std::uint64_t</type><parameter> mask</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the channel trigger mask for
                                channel <parameter>ch</parameter> to be
                                <parameter>mask</parameter>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>TraceRecordMode </type>
                              <methodname>getTraceRecordMode</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>ch</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns when a channel;
                                <parameter>ch</parameter> will make traces available
                                to the host (which must then request it in the
                                event format). Values returned are
                                <type>caen_nscldaq::VX2750Pha::TraceRecordMode</type>
                                enumerated types which ave the possible values:
                                <literal>caen_nscldaq::VX2750Pha::Always</literal>
                                and <literal>caen_nscldaq::VX2750Pha::OnRequest</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setTraceRecordMode</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>ch</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>TraceRecordMode </type><parameter>mode</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the trace recording mode for channel
                                <parameter>ch</parameter> to
                                <parameter>mode</parameter>.
                                See <methodname>getTraceRecordMode</methodname>
                                for a description of the <parameter>mode</parameter>
                                parameter values.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>TRGOUTMode    getTRGOUTMode</type>
                              <methodname>getTRGOUTMode</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the signal that has been selected to be
                                output on the TRGOUT NIM output.  The value
                                returned is of the enumerated type
                                <type>caen_nscldaq::VX2750Pha::TRGOUTMode</type>
                                which can have the following values:
                               </para>
                               <itemizedlist>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::TriggerOut_TRGIN</literal>
                                      The front panel TRGIN is propagated to TRGOUT.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::TriggerOut_P0</literal>
                                      the P0 trigger is propagated to the TRGOUT.
                                      This is not (yet) implemented in the hardware/firmware.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::TriggerOut_Software</literal>
                                      Software triggers are propagated as pulses to the TRGOUT
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::TriggerOut_LVDS</literal>
                                      Trigger inputs from the LVDS pins
                                      are propagated to TRGOUT.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::TriggerOut_InternalA</literal>
                                      the output of trigger logic block A is
                                      propagated to TRGOUT.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::TriggerOut_InternalB</literal>
                                      the output of trigger block B is propagated to
                                      TRGOUT
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::TriggerOut_InternalAandInternalB</literal>
                                      outputs the boolean and of the outputs of the
                                      internal trigger logic blocks A and B.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::TriggerOut_InternalAorInternalB</literal>
                                      outputs the boolean or of the outputs of the internal
                                      trigger logic blocks A and B.
                                   </para>
                                </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_EncodedClockIn</literal>
                                     The CLK-In is proppagated to TRGOUT.  Can be used
                                     to extend the clock daisy chain to NIM.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_Run</literal>
                                     True when the digitizer is running.  This output is
                                     timed prior to applying the Run delay time.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_ReferenceClock</literal>
                                     Monitors the internal 62.5MHz internal clock.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_TestPulse</literal>
                                     monitors test pulse timing.  
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                    <literal>caen_nscldaq::VX2750Pha::TriggerOut_Busy</literal>
                                    monitors the digitizer's busy.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_Zero</literal>
                                     Constantly deasserted.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_One</literal>
                                     Constantly asserted.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_SynchIn</literal>
                                     reflects the Synch in signal.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_SIN</literal>
                                     Reflects the SIN input.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerOut_GPIO</literal>
                                     Reflects the GPIO as an input.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::AcceptedTrigger</literal>
                                     Indicates a trigger was accepted.
                                  </para>
                               </listitem>
                               <listitem>
                                  <para>
                                     <literal>caen_nscldaq::VX2750Pha::TriggerClock</literal>
                                     Reflects the clock which determines the
                                     resolution of trigger timing.
                                  </para>
                               </listitem>
			     </itemizedlist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setTRGOUTMode</methodname>
                              <methodparam>
                                  <type>TRGOUTMode </type><parameter>mode</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Selects the functionality of the
                                TRGOUT NIM output.
                                See <methodname>getTRGOUTMode</methodname> for
                                a description of the possible values you can
                                supply for <parameter>mode</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>GPIOMode </type>
                              <methodname>getGPIOMode</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the functionality selected for the
                                GPIO connector if it is aNIM output.  The returned value is
                                a <type>caen_nscldaq::VX2750Pha::GPIOMode</type>
                                enumerated value which can be one of:
                               </para>
                               <itemizedlist>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_Disabled</literal>,
                                      The GPIO is not used.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_TriggerIn</literal>
                                      The GPIO is an output that reflects the TRGIN
                                      signal.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_P0</literal>
                                      The GPIO is an output that reflects the
                                      backplane P0 trigger (not yet implemented I believe).
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_SIN</literal>
                                      Propagates the value of the SIN NIM input
                                      as an output.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_LVDS</literal>
                                      Propagates the LVDS trigger inputs if they
                                      are selected as such.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_InternalA</literal>
                                      reflects the output of internal trigger logic
                                      block A
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_InternalB</literal>
                                      reflects the output of internal trigger logic
                                      block B
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                       <literal>caen_nscldaq::VX2750Pha::GPIOMode_InternalAandInternalB</literal>
                                       reflects the boolean and of the outputs of the
                                       two internal trigger logic blocks.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_InternalAorInternalB</literal>
                                      reflects the boolean or of the output sof the
                                      two internal triger logic blocks.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_EncodedClockIn</literal>
                                      Propagates the CLK-IN (Not yet implemented).
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_SoftwareTrigger</literal>
                                      Pulses when the board is given a software trigger
                                      command.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_Run</literal>
                                      Reflects the digitizer Run state.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_RefernceClock</literal>
                                      Reflects the internal 62.5Mhz oscillator.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_TestPulse</literal>
                                      reflects the test pulser timing.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_Busy</literal>
                                      Reflects the board busy state.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_Zero</literal>
                                      constantly deasserted.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::GPIOMode_One</literal>
                                      constantly asserted.
                                   </para>
                                </listitem>
                               </itemizedlist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setGPIOMode</methodname>
                              <methodparam>
                                  <type>GPIOMode </type><parameter>mode</parameter>
                              </methodparam>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Selects the functionality of the
                                GPIO if used as an output.  The values for the
                                <parameter>mode</parameter> parameter are
                                described above in the documentation of
                                <methodname>getGPIOMode</methodname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>BusyInSource   </type>
                              <methodname>getBusyInputSource</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                In a lock-step trigger system, all boards may need
                                to run with a common busy in order to prevent
                                some boards from triggering while others are busy.
                                This method returns the source of the external busy
                                for the board.
                               </para>
                               <para>
                                The result is a
                                <type>caen_nscldaq::VX2750Pha::BusyInSource</type>
                                enumerated type which can have the values:
                               </para>
                               <itemizedlist>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::BusyIn_SIN</literal>
                                      The SIN NIM input forces the board busy.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::BusyIn_GPIO</literal>
                                      The NIM GPIO connector is programmed as an
                                      input and it can force the board busy.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::BusyIn_LVDS</literal>
                                      LVDS inputs can be used as a busy.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <literal>caen_nscldaq::VX2750Pha::BusyIn_Disabled</literal>
                                      The board has no external busy source.
                                   </para>
                                </listitem>
                               </itemizedlist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>setBusyInputSource</methodname>
                              <methodparam>
                                  <type>BusyInSource</type><parameter> src</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the board external busy source.
                                See the documentation for
                                <methodname>getBusyInputSource</methodname>
                                for possible values of the <parameter>src</parameter>
                                parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>SyncOutMode </type>
                              <methodname>getSyncOutMode</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the selection for the signal source of
                                the SYNC OUT NIM output.  The Possible values are
                                an enumerated type: <type>caen_nscldaq::VX2750Pha::SyncOut</type>
                                which can have the one of the values:
                                <literal>caen_nscldaq::VX2750Pha::SyncOut_Disabled</literal>,
                                <literal>caen_nscldaq::VX2750Pha::SyncOut_SynchIn</literal>,
                                <literal>caen_nscldaq::VX2750Pha::SyncOut_TestPulse</literal>,
                                <literal>caen_nscldaq::VX2750Pha::InternalClock</literal>
                                or
                                <literal>caen_nscldaq::VX2750Pha::SyncOut_Run</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setSyncOutMode</methodname>
                              <methodparam>
                                  <type>SyncOutMode </type><parameter>mode</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the source of the SYNC OUT NIM output.
                                Valid values for <parameter>mode</parameter>
                                have been listed above in the description
                                for <methodname>getSyncOutMode</methodname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>VetoSource    </type>
                              <methodname>getBoardVetoSource</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the source of the board level trigger veto.
                                The value retunred is of type
                                <type>caen_nscldaq::VX2750Pha::VetoSource</type>
                                which is an enumerated type with the following
                                allowed values:
                                <literal>caen_nscldaq::VX2750Pha::Veto_SIN</literal>,
                                <literal>caen_nscldaq::VX2750Pha::Veto_LVDS</literal>,
                                <literal>caen_nscldaq::VX2750Pha::Veto_GPIO</literal>,
                                <literal>caen_nscldaq::VX2750Pha::Veto_P0</literal>,
                                <literal>caen_nscldaq::VX2750Pha::Veto_EncodedClock</literal>,
                                or <literal>caen_nscldaq::VX2750Pha::Veto_Disabled</literal>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname> setBoardVetoSource</methodname>
                              <methodparam>
                                  <type>VetoSource </type><parameter>src</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Select the board veto source.  The legal values for
                                <parameter>src</parameter> are listed in the
                                documentation for
                                <methodname>getBoardVetoSource</methodname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>getBoardVetoWidth</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returnth width of the number of ns the board level
                                veto is stretched after the veto condition is removed.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                               <methodsynopsis>
                                   <type>void   </type>
                                   <methodname>setBoardVetoWidth</methodname>
                                   <methodparam>
                                       <type>std::uint64_t </type><parameter>ns</parameter>
                                   </methodparam>
                                   <modifier>const</modifier>
                                </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Sets the number of nanoseconds the board veto
                                is stretched after the veto condition is removed to
                                <parameter>ns</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>VetoPolarity  </type>
                              <methodname>getBoardVetoPolarity</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the polarity of the board level veto.
                                If the value is <literal>caen_nscldaq::VX2750Pha::ActiveHigh</literal>,
                                the veto serves as an inhibit of the trigger.
                                If the value is <literal>caen_nscldaq::VX2750Pha::ActiveLow</literal>,
                                the veto serves as a gate for the board level trigger.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                                <methodsynopsis>
                                   <type>void  </type>
                                   <methodname>setBoardVetoPolarity</methodname>
                                   <methodparam>
                                       <type>VetoPolarity </type><parameter>pol</parameter>
                                   </methodparam>
                                </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Sets the polarity of the board veto source
                                to <parameter>pol</parameter>. Possible values
                                 are described in <methodname>getBoardVetoPolarity</methodname>
                                 above.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>ChannelVetoSource </type>
                              <methodname>getChannelVetoSource</methodname>
                              <methodparam>
                                  <type>unsigned</type><parameter>chan</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                In addition to a board level veto/gate, each channel
                                has a veto/gate.  This method returns the source
                                for the veto for channel <parameter>chan</parameter>.
                                The type is <type>caen_nscldaq::VX2750Pha::ChannelVetoSource</type>
                                which is an enumerated type with the following possible
                                values:
                                <literal>caen_nscldaq::VX2750Pha::BoardVeto</literal>,
                                <literal>caen_nscldaq::VX2750Pha::OverSaturation</literal>,
                                <literal>caen_nscldaq::VX2750Pha::Undersaturation</literal>,
                                or <literal>caen_nscldaq::VX2750Pha::ChanVeto_Disabled</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                                <methodsynopsis>
                                   <type>void</type>
                                   <methodname>setChannelVetoSource</methodname>
                                   <methodparam>
                                       <type>unsigned</type><parameter>chan</parameter>
                                   </methodparam>
                                   <methodparam>
                                       <type>ChannelVetoSource</type><parameter>src</parameter>
                                   </methodparam>
                                   <modifier>const</modifier>
                                </methodsynopsis>
                            </term>
                            <listitem>  
                                <para>
                                    Sets the veto source for channel
                                    <parameter>chan</parameter> to be
                                    <parameter>src</parameter>.  Valid values
                                    for <parameter>src</parameter> are described
                                    in the documentaiton for
                                    <methodname>getChannelVeotSource</methodname>
                                    above.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::uint32_t </type>
                               <methodname>getChannelVetoWidth</methodname>
                               <methodparam>
                                   <type>unsigned</type><parameter>chan</parameter>
                               </methodparam>
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Each channel veto can be stretched a number of
                                nanoseconds beyond when the veto condition ends.
                                This method returns the stretch in nanoseconds of
                                the veto from channel <parameter>chan</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setChannelVetoWidth</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>std::uint32_t</type><parameter> ns</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the stretch for the veto for channel
                                <parameter>chan</parameter> to
                                <parameter>ns</parameter> nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t </type>
                              <methodname>getRunDelay</methodname>
                              <void />
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                When the start of run is controlled by a RUN
                                signal that is propagated in daisy chain between
                                the boards (for instance
                                through the ClkIn-ClkOut or SIN-GPIO sync chain),
                                it is necessary to compensate for the propagation
                                delay in order for the
                                boards to start exactly at the same time,
                                since it is the start which zeroes the boards
                                timestamp clock.
                                The Run Delay parameter delays the start of the run
                                given number of nanoseconds with respect to the
                                rising edge of the RUN signal
                               </para>
                               <para>
                                This method returns the run delay parameter in
                                nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setRunDelay</methodname>
                              <methodparam>
                                  <type>std::uint32_t </type><parameter>ns</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the run start delay to
                                <parameter>ns</parameter> nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool  </type>
                              <methodname>isAutoDisarmEnabled</methodname>
                              <void /> <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                If external signals are used to start/stop
                                acquisition, it may be necessary to disable
                                restart until the software is ready.
                                Auto disarm mode disarms the digitizer when the
                                run stops making it insensitive to subsequent
                                starts until re-armed.  This method
                                retuns <literal>true</literal> if auto-disarm
                                was enabled.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setAutoDisarmEnabled</methodname>
                              <methodparam>
                                  <type>bool </type><parameter>state</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the state of the digitizer auto-disam.
                                If <parameter>state</parameter> is <literal>true</literal>,
                                auto disarm is enabled.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::unit32_t</type>
                               <methodname>getLEDStatus</methodname>
                               <void /> <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the state of the front panel LEDs.
                                The bits in the returned mask have
                                symbolic definition of the form:
                                <literal>caen_nscldaq::VX2750Pha::LEDFP_xxxxx</literal>:
                                <literal>LEDFP_JESD_Y_PASS = 1</literal>,
                                <literal>LEDFP_JESD_H_PASS = 2</literal>,
                                <literal>LEDFP_DDR4_0_PASS = 4</literal>,
                                <literal>LEDFP_DDR4_1_PASS = 8</literal>,
                                <literal>LEDFP_DDR4_2_PASS = 0x10</literal>,
                                <literal>LEDFP_FAIL = 0x20</literal>,
                                <literal>LEDFP_NIM = 0x40</literal>,
                                <literal>LEDFP_TTL = 0x80</literal>,
                                <literal>LEDFP_DTLOSS = 0x100</literal>,
                                <literal>LEDFP_DTRDY  = 0x200</literal>,
                                <literal>LEDFP_TRG = 0x400</literal>,
                                <literal>LEDFP_RUN = 0x800</literal>,
                                 <literal>LEDFP_PLL_LOCK  = 0x1000</literal>,
                                 <literal>LEDFP_CLKOUT = 0x2000</literal>,
                                 <literal>LEDFP_CLKIN     = 0x4000</literal>,
                                 <literal>LEDFP_USB       = 0x8000</literal>,
                                 <literal>LEDFP_SFP_SD    = 0x10000</literal>,
                                 <literal>LEDFP_SFP_ACT   = 0x20000</literal>,
                                 and <literal>LEDFP_ACT  = 0x40000</literal>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t </type>
                              <methodname>getAcquisitionStatus</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns a 32 bit mask that contains acquisition
                                status bits.  The header defines several
                                <literal>caen_nscldaq::VX2750Pha::ACQ_xxxx</literal>
                                symbolic constants for the bits:
                                <literal>ACQ_ARMED = 1</literal>,
                                <literal>ACQ_RUN = 2</literal>,
                                <literal>ACQ_RUN_MW = 4</literal>,
                                <literal>ACQ_JESD_CLK_VALID = 8</literal>,
                                <literal>ACQ_BUSY = 0x10</literal>,
                                <literal>ACQ_PRETRIGGER_READY = 0x20</literal>,
                                and <literal>ACQ_LICENSE_FAIL = 0x40</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t </type>
                              <methodname>getMaxRawDataSize</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                This should be called after the raw endoint
                                data format has been described.  It will return
                                the size of the data buffer that should be
                                declared to receive data from the raw endpoint.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type> double        </type>
                              <methodname>getVolatileClockDelay</methodname>
                              <void /> <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Retrieves the current clock edge delay in picoseconds.
                                This delay compensates for the phases drift in the
                                clock daisy chain as the clock propagates from module
                                to module.  
                               </para>
                               <para>
                                Note that there are two clock delay parameters.  The
                                volatile clock delay is delay currently in effect.
                                It may differ from the permanent clock delay which
                                is what is programmed in at board power up. One
                                normally plays with the volatile clock delay until
                                the clock phases are aligned on all boards and
                                then, finally, sets the good value to be the
                                new permanent clock delay so that the power up value
                                of the clock delay is correct.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setVolatileClockDelay</methodname>
                              <methodparam>
                                  <type>double </type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the volatile clock delay parameter to
                                <parameter>value</parameter> picoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double        </type>
                              <methodname>getPermanentClockDelay</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the clock delay that was programmed
                                in at power up.  Units are picoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setPermanentClockDelay</methodname>
                              <methodparam>
                                  <type>double</type><parameter> value</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Programs the power up (permanent) clock delay
                                to <parameter>value</parameter> picoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>WaveDataSource </type>
                              <methodname>getWaveDataSource</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                While normally the data into the DPP-PHA
                                firmware is directly the digitized inputs to the
                                 ADC, it is possible to program the digitizing
                                 circuitry to use different data sources for
                                 each channel.  This method
                                 returns the DPP-PHA waveform input to channel
                                 <parameter>chan</parameter>.
                               </para>
                               <para>
                                The resturn value is one of the values
                                of the enumerated type
                                <type>caen_nscldaq::VX2750Pha::WaveDataSource</type>
                                which can have one of the following values:
                                <literal>caen_nscldaq::VX2750Pha::ADC_DATA</literal>,
                                <literal>caen_nscldaq::VX2750Pha::ADC_TEST_TOGGLE</literal>,
                                <literal>caen_nscldaq::VX2750Pha::ADC_TEST_RAMP</literal>,
                                 <literal>caen_nscldaq::VX2750Pha::ADC_SIN</literal>,
                                 <literal>caen_nscldaq::VX2750Pha::WaveSource_IPE</literal>,
                                 <literal>caen_nscldaq::VX2750Pha::WaveSource_Ramp</literal>,
                                 <literal>caen_nscldaq::VX2750Pha::SquareWave</literal>,
                                 and
                                 <literal>caen_nscldaq::VX2750Pha::WaveDataSource::ADC_TEST_PRBS</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setWaveDataSource</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>WaveDataSource </type><parameter>source</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Selects the data source for the DPP-PHA firmware
                                for channel <parameter>chan</parameter>
                                to be <parameter>source</parameter>.  The
                                <methodname>getWaveDataSource</methodname>
                                method describes the valid values for
                                <parameter>source</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t </type>
                              <methodname>getRecordSamples</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the number of waveform samples that will be
                                recorded on a trigger for channel <parameter>chan</parameter>.  This includes the samples
                                prior to the trigger.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setRecordSamples</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>std::uint32_t </type><parameter>samples</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the totaln number of samples that will be
                                recorded for channel <parameter>chan</parameter>
                                to <parameter>samples</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t </type>
                              <methodname>getRecordNs</methodname>
                              <methodparam>
                                  <type>unsigned</type><parameter> chan</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>getRecordSamples</methodname>,
                                but the number of samples is converted to nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type> void </type>
                              <methodname>setRecordNs</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>std::uint32_t </type><parameter>ns</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>setRecordSamples</methodname>
                                but <parameter>ns</parameter> is the number of
                                desired nanoseconds of waveform to record.
                                This is converted to the nearest number of
                                samples. Note that this means that calling this
                                method and then
                                calling <methodname>getRecordNs</methodname>
                                may give slightly different value than the set value.
                                
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>WaveResolution </type>
                              <methodname>getWaveResolution</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the waveform resolution selected for channel
                                <parameter>chan</parameter>.  The returned value
                                is one of the valid values of the
                                <type>caen_nscldaq::VX2750Pha::WaveResolution</type>
                                enumerated data type.  The numbers in the symbols
                                represent the resolution in nanoseconds.
                                <literal>caen_nscldaq::VX2750Pha::Res8</literal>,
                                <literal>caen_nscldaq::VX2750Pha::Res16</literal>,
                                <literal>caen_nscldaq::VX2750Pha::Res32</literal>,
                                or
                                <literal>caen_nscldaq::VX2750Pha::Res64</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void</type>
                              <methodname>setWaveResolution</methodname>
                              <methodparam>
                                  <type>unsigned</type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>WaveResolution</type><parameter>resolution</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Set the waveform resolution for channel
                                <parameter>chan</parameter> to the
                                resolution indicated by the value of
                                <parameter>resolution</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>AnalogProbe  </type>
                              <methodname>getAnalogProbe</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>unsigned probeNum</type><parameter></parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                In addition to the results of the DPP-PHA
                                analysis of the captured waveform, an event can
                                include zero, one or two
                                <firstterm>analog probes</firstterm>.  This is
                                waveform data that is included in the event.
                               </para>
                               <para>
                                <methodname>getAnalogProbe</methodname>
                                interrogates analog probe number
                                <parameter>probeNum</parameter> for
                                channel <parameter>chan</parameter>.
                                The result is a value from the enumerated type
                                <type>caen_nscldaq::VX2750Pha::AnalogProbe</type>:
                                <literal>caen_nscldaq::VX2750Pha::ADCInput</literal>,
                                <literal>caen_nscldaq::VX2750Pha::TimeFilter</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EnergyFilter</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EnergyFilterBaseline</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EnergyFilterMinusBaseline</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void</type>
                              <methodname>setAnalogProbe</methodname>
                              <methodparam>
                                  <type>unsigned</type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>unsigned</type><parameter>probeNum</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>AnalogProbe</type><parameter>probe</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets analog probe number <parameter>probeNum</parameter>
                                for channel <parameter>chan</parameter> to the
                                probe selected by <parameter>probe</parameter>.
                                See <methodname>getAnalogProbe</methodname> for
                                a description of the
                                <type>caen_nscldaq::VX2750Pha::AnalogProbe</type>
                                data type.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                                <methodsynopsis>
                                   <type>DigitalProbe  </type>
                                   <methodname>getDigitalProbe</methodname>
                                   <methodparam>
                                       <type>unsigned chan</type><parameter></parameter>
                                   </methodparam>
                                   <methodparam>
                                       <type>unsigned </type><parameter>probeNum</parameter>
                                   </methodparam><modifier>const</modifier>
                                </methodsynopsis>
                                
                           </term>
                           <listitem>
                               <para>
                                Each event from a channel trigger can include
                                up to 4 digital probes. A digital probe is just
                                a set of boolean values aligned in time with
                                input waveform values. Samples from a digital probe
                                are represented by a single byte that contains
                                either 0 or 1.
                               </para>
                               <para>
                                This method returns the digital probe selected as
                                probe number <parameter>probenum</parameter>
                                for channel <parameter>chan</parameter>.
                                The result is a member of the enumerated type:
                                <type>caen_nscldaq::VX2750Pha::DigitalProbe</type>:
                                <literal>caen_nscldaq::VX2750Pha::DProbe_Trigger</literal>,
                                <literal>caen_nscldaq::VX2750Pha::TimeFilterArmed</literal>,
                                <literal>caen_nscldaq::VX2750Pha::ReTriggerGuard</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EnergyFilterBaselineFreeze</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EnergyFilterPeaking</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EnergyFilterPeakReady</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EnergyFilterPileupGuard</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EventPileup</literal>,
                                <literal>caen_nscldaq::VX2750Pha::ADCSaturation</literal>,
                                <literal>caen_nscldaq::VX2750Pha::ADCSaturationProtection</literal>
                                <literal>caen_nscldaq::VX2750Pha::PostSaturationEvent</literal>,
                                <literal>caen_nscldaq::VX2750Pha::EnergyFilterSaturation</literal>,
                                or <literal>caen_nscldaq::VX2750Pha::AcquisitionInhibit</literal>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void</type>
                              <methodname>setDigitalProbe</methodname>
                              <methodparam>
                                  <type>unsined</type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>unsigned probenum</type><parameter></parameter>
                              </methodparam>
                              <methodparam>
                                  <type>DigitalProbe</type><parameter>probe</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Selects which digital probe, <parameter>probe</parameter>,
                                will be used as probe number
                                <parameter>probeNum</parameter> for channel number
                                <parameter>chan</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t </type>
                              <methodname>getPreTriggerSamples</methodname>
                              <methodparam>
                                  <type>unsigned</type><parameter> chan</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the number of samples that will be collected
                                prior to the trigger
                                from channel <parameter>chan</parameter> and submitted to the DPP-PHA
                                firmware.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setPreTriggerSamples</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>std::uint32_t </type><parameter>nsamples</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the number of samples that will be collected
                                prior to the trigger of channel <parameter>chan</parameter>
                                to <parameter>nsamples</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t </type>
                              <methodname>getPreTriggerNs</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>getPreTriggerSamples</methodname>,
                                but the number of samples is converted to
                                nanosecond units.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setPreTriggerNs</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>std::uint32_t </type><parameter>ns</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>setPreTriggerSamples</methodname>
                                but <parameter>ns</parameter> are converted from
                                nanosecond to the nearest number of samples.
                                Note that the actual number of nanoseconds
                                pretrigger will can be gotten using
                                <methodname>getPreTriggerNs</methodname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>getTestPulsePeriod</methodname>
                              <void /> <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the period of the test pulser in nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setTestPulsePeriod</methodname>
                              <methodparam>
                                  <type>std::uint64_t</type><parameter> ns</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Set the test pulser period to <parameter>ns</parameter>
                                nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>getTestPulseWidth</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the test pulser pulse width in
                                nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type> void </type>
                              <methodname>setTestPulseWidth</methodname>
                              <methodparam>
                                  <type>std::uint64_t</type><parameter> ns</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Set the test pulse pulse width to
                                <parameter>ns</parameter> nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t</type>
                              <methodname> getTestPulseLowLevel</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the low level of the test pulser in
                                FADC units (0-65535).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void   </type>
                              <methodname>setTestPulseLowLevel</methodname>
                              <methodparam>
                                  <type>std::uint32_t </type><parameter>counts</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Set the test pulser low level to
                                <parameter>counts</parameter> FDAC units.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t</type>
                              <methodname> getTestPulseHighLevel</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the high level of the test pulser in
                                FADC units (0-65535).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void   </type>
                              <methodname>setTestPulseHighLevel</methodname>
                              <methodparam>
                                  <type>std::uint32_t </type><parameter>counts</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Set the test pulser high level to
                                <parameter>counts</parameter> FDAC units.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>IOLevel  </type>
                              <methodname>getIOLevel</methodname>
                              <void /> <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the NIM connector signalling levels.
                                The return value is of the enumerated type
                                <type>caen_nscldaq::VX2750Pha::IOLevel</type>
                                and can be one of
                                <literal>caen_nscldaq::VX2750Pha::TTL</literal>
                                or
                                <literal>caen_nscldaq::VX2750Pha::NIM</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void  </type>
                              <methodname>setIOLevel</methodname>
                              <methodparam>
                                  <type>IOLevel </type><parameter>level</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sets the I/O signalling level of the front panel
                                NIM connectors.  See
                                <methodname>getIOLevel</methodname> for legal
                                values of <parameter>level</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double</type>
                              <methodname>getAirInTemp</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the temperature in C at the board air intake.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double </type>
                              <methodname>getAirOutTemp</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the temperature in C at the board outflow.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double</type>
                              <methodname>getCoreTemp</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the temperature at the FPGA core.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double</type>
                              <methodname>getFirstADCTemp</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the temperature of the first ADC along
                                the airflow
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double</type>
                              <methodname>getLastADCTemp</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the temperature of the last ADC along the
                                airflow.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double</type>
                              <methodname>getHottestADCTemp</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the temperature of the hottest ADC.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double</type>
                              <methodname>getADCTemp</methodname>
                              <methodparam>
                                  <type>unsigned</type><parameter>chip</parameter>
                              </methodparam><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the temperature at the specified ADC ship.
                                <parameter>chip</parameter> is in the inclusive
                                range 0-7.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double</type>
                              <methodname>getDCDCConverterTemp</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the temperature at the DC-DC converter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type> double </type>
                              <methodname>getDCDCConverterInputVoltage</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the input voltage (in volts) to the
                                board's DC-DC converter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double  </type>
                              <methodname>getDCDCConverterOutputVoltage</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the DC-DC converter output voltage in volts.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double </type>
                              <methodname>getDCDCConverterAmps</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the current output of the DC-DC converter in
                                amps.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double  </type>
                              <methodname>getDCDCConverterHz</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Return the DC-DC converter frequency in Hz.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type> double</type>
                              <methodname>getDCDCConverterDutyCycle</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the DC-DC converter duty factor in percentage.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint32_t </type>
                              <methodname>getFanSpeed</methodname>
                              <methodparam>
                                  <type>unsigned</type><parameter> fan</parameter>
                              </methodparam>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the speed, in RPM of fan number
                                <parameter>fan</parameter>.  Ther are two fans,
                                0, and 1.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
                <refsect1>
                    <title>EXPORTED DATA</title>
                    <para></para>
                </refsect1>
            </refentry>
        </section>
    </appendix>
</book>
