<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>NSCLDAQ support for the CAEN VXxxxx series of digitizers with DPP-PHA.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>October 7, 2022</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
      <corpcredit>CAEN Technologies</corpcredit>
      <address><email>ron@caentechnologies.com</email></address>
    </bookinfo>
    <chapter id='ch.intro'>
        <title>Introduction</title>
        <para>
            This document describes how to configure and use the NSCLDAQ support
            for the new generation of CAEN VXxxxx digitizers.  I assume that:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  You have a basic familiarity with NSCLDAQ, how to configure it
                  and how to use its event builder.
               </para>
            </listitem>
            <listitem>
               <para>
                  You have a basic familiarity with how to use and tailor
                  the SpecTcl analysis package (if you choose to use this
                  for analysis).
               </para>
            </listitem>
            <listitem>
               <para>
                  You are familiar with the configuration parameters of the
                  DPP-PHA firmware supported by these modules.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that NSCLDAQ and SpecTcl documentation are all online at
            <ulink url='http://docs.nscl.msu.edu/daq' />.   Problems and questions
            about NSCLDAQ and SpecTcl (outside the scope of the CAEN Vxxxx digitizers)
            should be addressed to <ulink url='mailto:helpme@frib.msu.edu' />.
        </para>
        <para>
            The document is therefore organized into the following chapters:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  <link linkend='ch.readout' endterm='ch.readout.title'/> describes
                  how to create and configure a customized Readout program which
                  will inject data from a set of ADCs into the NSCLDAQ data flow
                  system.   Within that chapter,
                  <link linkend='sec.rdoprogramming' endterm='sec.rdoprogramming.title' />
                  describes the changes needed to the SBS readout skeleton.  The
                  format of events readout by this program will also be described.
                  <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />
                  describes how the modules are configured and how to write a
                  configuration file for your readout software.
               </para>
            </listitem>
            <listitem>
               <para>
                   <link linkend='ch.spectcl' endterm='ch.spectcl.title' />
                   describes how to build a tailored version of SpecTcl to produce
                   raw parameters from the modules  you are reading out. 
               </para>
            </listitem>
        </itemizedlist>
        <para>
            For those interested an appendix describes the structure of the software
            as well as items for further development.
        </para>
        <para>
            The <filename>tclreadout</filename> subdirectory of the source tree
            gives a sample tailored readout program for the readout software
            described in <link linkend='ch.readout' endterm='ch.readout.title' />.
            The <filename>tclreadout/SpecTcl</filename> subdirectory of the source
            tree gives a sample tailored SpecTcl program for this example.
        </para>
    </chapter>
    <chapter id='ch.readout'>
        <title id='ch.readout.title'>Getting Data</title>
        <para>
            Data is read from modules using a tailored SBS readout program that
            makes use of classes that have been written to support the new
            CAEN VXxxxx digitizers and DPP-PHA firmware.   These modules have
            a huge number of settable parameters.
        </para>
        <para>
            To manage the settable parameters, each module is associated with a
            <firstterm>configuration</firstterm>.  The module's configuration
            captures the desired settings for that module.  A module is assigned
            a name by your software and a matching named configuration is  read
            and used to configure that module at the start of each run.  The
            configuration is re-read each begin run so that changes can be made
            between runs.
        </para>
        <para>
            <link linkend='sec.rdoprogramming' endterm='sec.rdoprogramming.title' />
            describe how to tailor an SBS readout skeleton to produce a readout
            program.   <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />
            describes how to create module configurations and the parameters
            that can be set for a module.
        </para>
        <para>
            A few notes:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  While the software was developed with 12.0-pre, I believe the
                  support software will function with 11.3 as well.
               </para>
            </listitem>
            <listitem>
               <para>
                  Since each module is assigned a source id, when event building
                  the readout program should be run with the
                  <option>--no-barriers</option> optioon in order to prevent
                  the event builder from stalling on a barrier wait at the start
                  and end of runs.
               </para>
            </listitem>
        </itemizedlist>
        <section id='sec.rdoprogramming'>
            <title id='sec.rdoprogramming.title'>Obtaining and modifying the skeleton</title>
            <para>
                The Readout is based on the SBS readout skeleton.  This
                software allows for an experiment specific trigger which causes
                experiment specific code to be run.  SBS readout skeletons, therefore
                require tailoring to fit specific applications.

            </para>
            <para>
                Here are the steps required to tailor that system for the
                CAEN modules:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Select the version of NSCLDAQ you will use, and source in its
                      setup file to define environment variables that will make
                      your life easier.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Obtain a copy of the sbs skeleton in an emtpy directory. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Make appropriate modifications to the
                      <filename>Skeleton.cpp</filename>'s
                      <methodname>Skeleton::SetupReadout</methodname> method
                      to define the modules you will be using.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Modify the Makefile provided with the skeleton to pull in the
                      libraries and headers that make up support.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Build the Readout program. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Write a configuration file that appropriately configures
                      each module you defined (covered in
                      <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />).
                   </para>
                </listitem>
            </orderedlist>
            <para>
                The remainder of this section assumes you have selected
                NSCLDAQ-12.0-pre5.    To obtain that skeleton:
            </para>
            <example>
                <title>
                    Selecting DAQ version and obtaining the skeleton:
                </title>
                <programlisting>

source /usr/opt/daq/12.0-pre5/daqsetup.bash
mkdir myreadout
cd myreadout
cp $DAQROOT/skeletons/sbs/* .

                </programlisting>
            </example>
            <section>
                <title>Modifying the Skeleton</title>
                <para>
                    In this example, the key class is:
                    <classname>TclConfiguredReadout</classname> is a container
                    class that is an <firstterm>CEventSegement</firstterm> that
                    holds a set of modules to readout and constructs and appropriate
                    trigger to drive the readout.  It will also construct
                    and maintain objects for each module.
                </para>
                <para>
                    Construction specifies a configuration file that is processed
                    at the beginning of each run and used to program the
                    configuration of each module.
                </para>
                <para>
                    The class's <methodname>addModule</methodname> method
                    creates a module driver for a module, providing the connection
                    parameters for that module and associating it with a module
                    configuration within the configuration file. Each module,
                    so defined must be assigned a source id that is unique
                    across the system.  This source Id is used in event building.
                </para>
                <para>
                    Here are the parameter signatures for the methods you need
                    to use:
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>TclConfiguredReadout</methodname>
                            <methodparam>
                                <type>const char*</type><parameter>configfile</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CExperiment*</type><parameter>pExperiment</parameter>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>configfile</parameter> is the
                            path to a file that describes configurations for each
                            module that will be added to this event segment
                            (see <methodname>addModule</methodname>).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void</type>
                          <methodname>addModule</methodname>
                          <methodparam>
                              <type>const char*</type><parameter>name</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const char*</type><parameter>connectionString</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::uint32_t</type><parameter>sid</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool</type><parameter>isusb</parameter>
                              <initializer>false</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                                Adds a module to the readout.  <parameter>name</parameter>
                                is the name of a module in the configuration
                                file specified in the construtor.
                           </para>
                           <para>
                            <parameter>connectionString</parameter> is a string
                            that describes how the module is connected to the system.
                            This string is either a dotted IP address (e.g
                            "127.0.0.1") if ETHERNET is used or the PID of the module
                            if USB is used.  Note that DNS lookups are not done for
                            host names but there is nothing to stop you from doing
                            host lookups yourself prior to calling
                            <methodname>addModule</methodname>
                           </para>
                           <para>
                            <parameter>sid</parameter> is a unique integer source id
                            that identifies this module to the event builder.
                           </para>
                           <para>
                            <parameter>isUsb</parameter> is an optional parameter
                            that defaults to <literal>false</literal>.
                            If <literal>true</literal>, it specifies that the
                            <parameter>connectionString</parameter> is a module PID
                            and that the connection is via USB.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>CTrigger*</type>
                          <methodname>getTrigger</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the trigger that the object
                            has computed for the modules that have been added to it.
                            This should be used to supply a trigger object to the
                            Readout program framework.
                           </para>
                        </listitem>
                    </varlistentry>

                </variablelist>
                                <para>
                    Let's look at a simple example.  The full example is in
                    the <filename>tclreadout</filename> subdirectory of the
                    source tree.  If you want to use that as a starting point,
                    simply modify the <literal>INSTDIR</literal> definition
                    at the top of the file to point to the version of NSCLDAQ
                    you decided to use.
                </para>
                <example id='ex.skeleton'>
                    <title id='ex.skeleton.title'>Sample Skeleton.cpp modifications</title>
                    <programlisting>
#include &lt;config.h&gt;
#include &lt;Skeleton.h&gt;
#include &lt;CExperiment.h&gt;
#include &lt;TCLInterpreter.h&gt;
#include &lt;CTimedTrigger.h&gt;
#include &lt;TclConfiguredReadout.h&gt;   <co id='rdo.classinc' />
#include &lt;Dig2Device.h&gt;             <co id='rdo.tracinginc' />

...

void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
 
  CReadoutMain::SetupReadout(pExperiment);
  
  // turns on felib tracing if compiled with it enabled

  // caen_nscldaq::set_tracing(true);    <co id='rdo.tracing' />
  
  // First we create a TclConfiguredReadout object and describe the
  // connections to the modules in the system -- assigning each
  // module a distinct source id for event building.
  // Note that the event builder allows fragments from the same source to get
  // grouped into the same event and each fragment is tagged with its channel..
  // so per-module sids rather than per-channel work just fine:
  
  auto pSegment = new TclConfiguredReadout(   <co id='rdo.makesegment'/>
    "configuration.tcl",            // Detailed module settings file path.
    pExperiment                     // Pointer to experiment object.
  );
  pSegment-&gt;addModule(                    <co id='rdo.addmodule' />
    "adc1",                   // Name of module in configuration.tcl
    "15236",                   // PID for USB connection, IP If ethernet.
    1,                        // System unique source id.
    true                      // Indicates it's USB not Ethernet defaults to false.
  );
  
  pExperiment-&gt;AddEventSegment(pSegment);   <co id='rdo.registersegment' />
  
  // The event segment creates a dynamic multi trigger object which we need
  // to fetch out and register as the trigger for the system:
  
  pExperiment-&gt;EstablishTrigger(pSegment->getTrigger()); <co id='rdo.registertrigger' />
  
}


                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='rdo.classinc' >
                        <para>
                            This <literal>#include</literal> is needed to define
                            the <classname>TclConfiguredReadout</classname>
                            class.
                        </para>
                    </callout>
                    <callout arearefs='rdo.tracinginc' >
                        <para>
                            Wrappers for the CAEN libraries support tracing the
                            operations and responses performed on the module.
                            This header provides definitions needed to enable
                            this tracing.  Note that tracing must be enabled both
                            programmatically and via a compilation option in the
                            library Makefile.
                        </para>
                    </callout>
                    <callout arearefs='rdo.tracing' >
                        <para>
                            If the library has been built with tracing enabled,
                            uncommenting this line will turn that on. Note that this
                            will create a large trace file, as well as adversely
                            impact performance.
                        </para>
                    </callout>
                    <callout arearefs='rdo.makesegment' >
                        <para>
                            Creates the <classname>TclConfiguredReadout</classname>
                            object that will manage the modules we will use.
                            At the start of each run, <filename>configuration.tcl</filename>
                            will be processed to load the configuration for each
                            module and each module will then be asked to configure itself
                            in accordance with its configuration.  The
                            <parameter>pExperiment</parameter> pointer passed in
                            to <methodname>SetupReadout</methodname> points to
                            an object that provides services needed.
                        </para>
                        <para>
                            Note that <methodname>SetupReadout</methodname> is only
                            called once at system startup and the lifetime of the
                            <classname>TclConfiguredReadout</classname> will be
                            the lifetime of the Readout program.  Therefore,
                            the fact that the <varname>pSegment</varname>
                            never is deleted is not a memory leak.
                        </para>
                    </callout>
                    <callout arearefs='rdo.addmodule' >
                        <para>
                            Adds a module to the system.  The module is named
                            <literal>adc1</literal> and will, therefore expect
                            a configuration for <literal>adc1</literal>.
                            It is a USB connected module with PID 
                            <literal>15236</literal> and is assigned source id
                            <literal>1</literal>.
                        </para>
                        <para>
                            The <classname>TclConfiguredReadout</classname>
                            will manage this module from now on.  It will also
                            produce a part of the readout trigger based
                            on data being available in this module.
                        </para>
                    </callout>
                    <callout arearefs='rdo.registersegment' >
                        <para>
                            The <classname>TclConfiguredReadout</classname>
                            event segment is registered with the experiment framework
                            so that its methods will be invoked by that framework
                            when appropriate.
                        </para>
                    </callout>
                    <callout arearefs='rdo.registertrigger' >
                        <para>
                            The trigger computed by the
                            <classname>TclConfiguredReadout</classname> event
                            segment is fetched and established as the trigger
                            for readout.  When a run is active this trigger is
                            polled and, when it indicates that it has been
                            triggered, readout will ensue.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Modifying the Makefile and Building Readout</title>
                <para>
                    The CAEN digitizer support software (NSCLDAQ and base).  The
                    SBS skeleton readout Makefile must be edited to ensure that
                    appropriate include directories are searched when compiling
                    and libraries pulled in when linked:
                </para>
                <itemizedlist>
                    <listitem>
                       <para>
                          <literal>-lCAEN_FELib</literal>  must be added
                          to the definition of <varname>USERLDFLAGS</varname>
                          This links in the base CAEN library that provides
                          support for communicating with the digitizer.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          JavaScript Object Notation (JSON) is used to specify readout formats and a JSON
                          support library (JSONCPP) is used to format those requests.
                          This is a package that's installed in the containers
                          we distribute or, if you are running native, is a
                          debian package: <literal>libjsoncpp-dev</literal>
                          Due to headers that are included by other headers,
                          <literal>$(shell pkg-config jsoncpp --cflags)(</literal>
                          must be added to <varname>USERCCFLAGS</varname>
                          and <literal> $(shell pkg-config jsoncpp  --libs)</literal>
                          added to <varname>USERLDFLAGS</varname>
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Tracing FE library calls is done via the boost logging
                          package so
                          <literal>-lboost_log -lboost_log_setup  -lboost_thread -lboost_syste</literal>
                          must be added to <varname>USERLDFLAGS</varname>.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                           Finally we need to pull in the NSCLDAQ support
                           library.  Suppose the headers are all installed in
                           <literal>$(CAEN_NSCLDAQ)/include</literal> and
                           libraries in <literal>$(CAEN_NSCLDAQ)/lib</literal>.
                           <literal>-I$(CAEN_NSCLDAQ)/include</literal>
                           must be added to <varname>USERCCFAGS</varname> and
                           <literal>-L$(CAEN_NSCLDAQ)/lib -lCaenVx2750</literal>
                           to <varname>USERLDFLAGS</varname>
                       </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Once this has been done, the Readout program can be built
                    via <command>make</command>
                </para>
            </section>
        </section>
        <section id='sec.rdoconfig'>
            <title id='sec.rdoconfig.title'>Configuring modules</title>
            <para>
                Each module must be configured to be useful.  This is done by
                writing a configuration script.  Configuration scripts are
                written in a domain specific language layered on top of the
                Tcl scripting language.  Tcl is extended by adding a single command
                ensemble: <command>v27xxpha</command> to Tcl. 
            </para>
            <para>
                A command ensemble in Tcl parlance is a single command that has
                subcommands specified by the next word on the command line.  The
                <command>v27xxpha</command> command has the following forms:
            </para>
            <variablelist>
                <varlistentry>
                   <term><command>vx27xxpha create <replaceable>module-name</replaceable></command></term>
                   <listitem>
                       <para>
                        Creates a new configuration for a module <parameter>module-name</parameter>.
                        When the Readout initializes modules it looks for configurations
                        that match the names of modules that have been added
                        to the <classname>TclConfiguredReadout</classname>
                        module.
                       </para>
                       <para>
                        thus in our example
                        <link linkend='ex.skeleton' endterm='ex.skeleton.title' />
                         <command>vx27xxpha create adc1</command> would create
                         a configuration for the module we added.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha config <replaceable>module-name name value ...</replaceable></command></term>
                   <listitem>
                       <para>
                        Configures one or more parameter values for the
                        <parameter>module-name</parameter>.  Any number of
                        parameter name/value pairs can be specified on the command.
                        For example:
                        <command>v27xxpha config adc1 dcoffsets [lrepeat 64 0]</command>
                        Configures the DC offsets for all 64 channels to be 0% of
                        full scale.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha cget <replaceable>module-name name</replaceable></command></term>
                   <listitem>
                       <para>
                        This command returns the value of the parameter
                        <parameter>name</parameter> from the configuration
                        for the module <parameter>module-name</parameter>.
                        For example:
                        <command>puts [vx27xxpha cget adc1 dcoffsets]</command>
                        will print 64 zeroes to stdout.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha delete <replaceable>module-name</replaceable></command></term>
                   <listitem>
                       <para>
                        Really not necessary - this deletes the configuration
                        for <parameter>module-name</parameter>.  Since the
                        configuration file is processed and all configuration rebuilt
                        from scratch at each begin run,
                        there's really no need to delete modules.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx25x0 list</command></term>
                   <listitem>
                       <para>
                        Returns a list of the module names that have configurations.
                        the following little script will list the modules
                        configured, one per line to stdout:
                       </para>
                       <informalexample>
                        <programlisting>
foreach module [vx27xxpha list] {
    puts $module
}
                        </programlisting>
                       </informalexample>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                A sample configuration file that goes along with the
                sample readout program in the <filename>tclreadout</filename>
                subdirectory of the source tree is 
                <filename>/configuration.tcl</filename>.
            </para>
            <section>
                <title>Configuration parameter reference</title>
                <para>
                    This section consists of several subsections.  Each
                    subsection provides a reference for a set of configuration
                    parameters that are related in some way.
                    Parameters are describes as follows:
                </para>
                <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem><seg>Name of the parameter</seg>
                    <seg>Data type the item must be</seg>
                    <seg>Defeault value for the item</seg>
                    <seg>Description of the item.</seg>
                    </seglistitem>
                </segmentedlist>
                <para>
                    A note on the boolean data type.  Any of the following are
                    valid true values:
                    <literal>true, yes, 1, on, enabled</literal>, while any
                    of the following are valid false value
                    <literal>false, no, 0, off, disabled</literal>.
                </para>
                <para>
                    A note on integer data types.  These can be expressed in base
                    10, 16 or 8. Base 16 values should be prefixed by 0x,
                    e.g. <literal>0x5a5a5a5a5a5a5a5a</literal>.  Base 8 values
                    are prefixed by a leading zero e.g. 0777.
                    
                </para>
                <warning>
                    <title>WARNING</title>
                    <para>
                        Do not use leading zeros to align decimal values,
                        they will be treated as octal and, in general,
                        not have the intended effect.  This is a curse that has
                        afflicted many a user of the Tcl language.
                    </para>
                </warning>
                <para>
                    When in doubt about the meaning of a parameter see CAEN
                    document
                    <literal>UM7788 --FELib PHA Parameters User Manual</literal>.
                </para>
                <section>
                    <title>Readout Options</title>
                    <para>
                        The parameters in this section are not actually digitizer
                        parameters, the determine what is read from the
                        digitizer at each event.  All events will read the
                        event channel number, timestamp in nanosecods
                        and energy from the DPP-PHA.
                        These options allow additional available parameters/features
                        to be read from the digitizer.
                    </para>
                    <para>
                        The configuration parameters are:
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>readrawtimes</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the raw time stamp counter is included
                        in each event.  Note that the nanosecond timestamp
                        is always used for even building as the raw timestamp
                        may vary in frequency depending on the digitizer.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readfinetimestamps</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, and if the module supports the generation
                        of fine timing information (e.g. interpolated timing from
                        a CFD), turning this on enables the inclusion of that fine
                        timing information in the event.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readflags</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled reads various bits that report on the
                        digitizer's state</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readtimedownsampling</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, reads a code that corresponds to the
                        digitizer sampling scaledown</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readanalogprobes</seg>
                        <seg>list of two booleans</seg>
                        <seg>{false false}</seg>
                        <seg>The module supports two analog probes these can be used
                        to acquire the input waveforms as well as various diagnostic
                        information.  The first element of the list enables/disables
                        the inclusion of analog probe1 and the second the inclusion of
                        analog probe 2</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readdigitalprobes</seg>
                        <seg>list of four booleans</seg>
                        <seg>{false false false false}</seg>
                        <seg>The digitizer supports the inclusion of four digital probes.
                        A digital probe has a byte per sample with a value of 0 or
                        1.  The list can selectively enable the inclusion of data
                        from each probe.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readsamplecount</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the number of samples read for this
                        channel are included.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readeventsize</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the raw event size is read.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>General options</title>
                    <para>
                        These parameters control general module wide functionality.
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>clocksource</seg>
                        <seg>Enumerated</seg>
                        <seg><literal>Internal</literal></seg>
                        <seg>Selects the source of the digitizer's clock.
                        Valid values are <literal>Internal</literal>
                        to use the module's internal clock or
                        <literal>FPClkIn</literal> to use the front panel clock
                         input.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>outputfpclock</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If <literal>true</literal>, the digitizer clock is output
                        on the front panel.  This allows modules to use a single
                        shared clock source without needed an external clock.
                        Clock delays can then compensate for clock propagation
                        delays as one progresses  down the clock in/clock out
                        daisy chain.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Triggerring and I/O</title>
                    <para>
                        The parameters control digitizer and channel level triggers
                        as well as the LEMO connectors on the front panel.
                    </para>
                    <segmentedlist>
                    <title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>startsource</seg>
                        <seg>List of enumerated values</seg>
                        <seg>SWcmd</seg>
                        <seg>The list of ways the digitizer can start a run.
                        The digitzer is started on the or of the conditions
                        in the list.  Usually, in a synchronized set, the
                        'master' digitizer is stated on <literal>SWcmd</literal> and the others
                        on e.g. <literal>SINedge</literal>.   Valid values for list elements are:
                        <literal>EncodedClkIn, SINlevel, SINedge, SWcmd, LVDS, P0</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>gbltriggrsrc</seg>
                        <seg>List of Enums</seg>
                        <seg>TrgIn</seg>
                        <seg>The sources of the module global trigger.  The
                        or of the values listed makes a global trigger.
                        Valid values are
                        <literal>TrgIn, P0, SwTrg, LVDS, ITLA, ITLB,
                        ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn, GPIO,
                        TestPulse</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>wavetriggersrc</seg>
                        <seg>List of 64 lists of enums</seg>
                        <seg>[lrepeat TRGIN 64]</seg>
                        <seg>This parameter is a list of 64 trigger sources for
                        wave acquisition.  Each element of that list is itself
                        a list of triggers sources for that channel.  Valid
                        values for the trigger sources are:
                        <literal>
                            ITLB, ITLA, GlobalTriggerSource, TRGIN, ExternalInhibit,
                            ADCUnderSaturation, ADCOverSaturation, SWTrg, ChSelfTrigger,
                            Ch64Trigger, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>eventtriggersrc</seg>
                        <seg>List of 64 lists of enums</seg>
                        <seg>[lrepeat TRGIN 64]</seg>
                        <seg>Similar to the <literal>wavetriggersrc</literal>
                        but provides, for each channel a list of event trigger
                        sources.   Valid values are:
                        <literal>
                            ITLB, ITLA, GlobalTriggerSource, TRGIN, SWTrg, ChSelfTrigger,
                            Ch64Trigger, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>channeltriggermasks</seg>
                        <seg>List of 64 uint64_t</seg>
                        <seg>[lrepeat 0 64]</seg>
                        <seg>In <literal>Ch64Trigger</literal> mode, or coincidence
                        triggering mode, used to define the set of channels that
                        particpate in triggering each channel.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>savetraces</seg>
                        <seg>List of 64 enums</seg>
                        <seg>[lrepeat OnRequest 64]</seg>
                        <seg>Determines when wave traces are saved for each
                        channel.  Valid values are
                        <literal>Always, OnRequest</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>triggeroutmode</seg>
                        <seg>Enumerated value</seg>
                        <seg>TRGIN</seg>
                        <seg>Determines what is output on the <literal>TRGOUT</literal>
                        LEMO output.  Valid values are:
                        <literal>
                            TRGIN, P0, SwTrg, LVDS, ITLA, ITLB,
                            ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn,
                            Run, RefClk, TestPulse,
                            Busy, Fixed0, Fixed1, SyncIn, SIN, GPIO,
                            AcceptTrg, TrgClk
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>gpiomode</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>Selects the signal to output on the
                        GIO LEMO connector.
                        This can be one of
                        <literal>
                            Disabled, TrgIn, P0, SIN, LVDS, ITLA, ITLB,
                            ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn, SwTrg,
                            Run, RefClk, TestPulse, Busy, Fixed0, Fixed1
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>busyinsrc</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>Determines the source of the external
                        module busy input.  This is one of:
                        <literal>SIN, GPIO, LVDS, Disabled</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>syncoutmode</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>
                            Determines the source of the <literal>SOUT</literal>
                            LEMO connector.  Valid values are
                            <literal>
                                Disabled, SyncIn, TestPulse, IntClk, Run
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetosrc</seg>
                        <seg>Enumerated value</seg>
                        <seg>Source of the board level trigger veto. Valid values are
                        <literal>
                            SIN, LVDS, GPIO, P0, EncodedClkIn, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetowidth</seg>
                        <seg>Integer nano-seconds 0 - 34359738360</seg>
                        <seg>200</seg>
                        <seg>Ns stretch applied to the board veto source</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetopolarity</seg>
                        <seg>Enumerated value</seg>
                        <seg>ActiveLow</seg>
                        <seg>
                            Polarity of the veto input.  One of
                            <literal>ActiveHigh, ActiveLow</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetosrc</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Disabled 64]</seg>
                        <seg>Veto sources for each of the channels.  Each list element
                        can have one of the value:
                        <literal>
                            BoardVeto, ADCOverSaturation, ADCUnderSaturation, Disabled
                        </literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetowidth</seg>
                        <seg>List of 64 integer in units of ns 0-524280</seg>
                        <seg>[list 200 64]</seg>
                        <seg>The stretch applied to each channel's veto source.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>rundelay</seg>
                        <seg>Integer nanoseconds 0-54280</seg>
                        <seg>0</seg>
                        <seg>
                            This value is used to fine tune the synchronized
                            start of multi-board data taking. When the start source
                            is true, the actual start will be delayed by the ns
                            set in this parameter.  If, for example, the start is
                            propagated via a SIN/SOUT daisy chain on the front panel, the
                            final board will be delayed by 0 ns, the next to last
                            board by the single board propagation delay and so on.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetowidth</seg>
                        <seg>boolean</seg>
                        <seg>true</seg>
                        <seg>When true, the module is disarmed when data taking is
                        stopped.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>volclkoutdelay</seg>
                        <seg>Floating point ps -18888.8888 - 18888.8888</seg>
                        <seg>0.0</seg>
                        <seg>
                            Sets the value that is programmed into the clock PLL
                            delay.  This is used to synchronize clocks passed between
                            boards via the CLKOUT/CLKIN daisy chain.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>permclkoutdelay</seg>
                        <seg>volclkoutdelay</seg>
                        <seg>Floating point ps -18888.8888 - 18888.8888</seg>
                        <seg>0.0</seg>
                        <seg>
                            Sets the value that is programmed into the clock PLL
                            delay on power up.  This is used to synchronize clocks passed between
                            boards via the CLKOUT/CLKIN daisy chain.  Note that
                            this value is first programmed and then the volclkoutdelay
                            which actually controls the clock delay.
                            In a future bit of development a parameter migth be
                            added to select which of these two values controls
                            the actual clock delay.
                        </seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Wave form inspection and digital probes.</title>
                    <para>
                        Note that whlie the waveform and digital probe values are
                        programmed here, in order to actually include those
                        probes in the data read from the digitizer,
                        <literal>readanalogprobes</literal> and/or
                        <literal>readdigitalprobes</literal> must be set
                        accordingly.
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>wavesource</seg>
                        <seg>List of enumerated values</seg>
                        <seg>[lrepeat ADC_DATA 64]</seg>
                        <seg>
                            This is a list of one entry per channel that describes
                            what the FADC for that channel sees on its input.
                            Valid values are:
                            <literal>
                                ADC_DATA, ADC_TEST_TOGGLE, ADC_TEST_RAMP,
                                ADC_TEST_SIN, IPE,
                                 Ramp, SquareWave, ADC_TEST_PRBS
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>recordsamples</seg>
                        <seg>List of 64 integers 4-8100</seg>
                        <seg>[lrepeat 4 64]</seg>
                        <seg>Each element determines the number of samples that
                        channel of the ADC will process/record.  The actual time
                        represented depends on the value of the <literal>saveresolutions</literal>
                        parameter for that channel.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>waveresolutions</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Res8 64]</seg>
                        <seg>For each channel, selects the sampling resolution in
                        nanoseconds.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>analogprobe1, analogprobe2</seg>
                        <seg>List of 64 enumerated values</seg>
                        <seg>[lrepeat ADCInput 64], [lrepeat TimeFilter 64]</seg>
                        <seg>
                            For each channel, the analog probes available
                            for acquisition from that channel.   Allowed values
                            are:
                            <literal>
                                ADCInput, TimeFilter, EnergyFilter,
                                EnergyFilterBaseline,
                                EnergyFilterMinusBaseline
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>digitalprobe1, digitalprobe2, digitalprobe3, digitalprobe4</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Trigger 64], [lrepeat TimeFilterArmed 64],
                        [lrepeat RetriggerGuard 64],
                        [lrepeat EneryFilterBaselineFreeze 64]</seg>
                        <seg>
                            For each channel, the digital probes available for
                            acquisition from that channel.  Valid values are:
                            <literal>
                                Trigger, TimeFilterArmed, ReTriggerGuard,
                                EnergyFilterBaselineFreeze,
                                EnergyFilterPeaking, EnergyFilterPeakReady,
                                EnergyFilterPileUpGuard, EventPileup, ADCSaturation,
                                ADCSaturationProtection, PostSaturationEvent,
                                EnergyFilterSaturation,
                                AcquisitionInhibit
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>pretriggersamples</seg>
                        <seg>List of 64 integers 4-4000</seg>
                        <seg>[lrepeat 100 64]</seg>
                        <seg>For each channel, the number of samples
                        prior to the trigger that will be acquired and
                        analyzed by the DPP-PHA firmware.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Service options</title>
                    <para>
                        These, for the most part, have to do with the test pulser.
                        There are also miscellaneous parameters to control
                        error handling and the LEMO I/O levels.
                    </para>
                    <segmentedlist>
                        <title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>testpulserperiod</seg>
                        <seg>Integer ns 0-34359738360</seg>
                        <seg>100000</seg>
                        <seg>The period of the test puler in ns.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulsewidth</seg>
                        <seg>Integer ns 0-34359738360</seg>
                        <seg>1000</seg>
                        <seg>Width of the high part of the test pulser
                        period.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulselowlevel</seg>
                        <seg>Integer 0-65535</seg>
                        <seg>0</seg>
                        <seg>The low level output of the pulser</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulsehighlevel</seg>
                        <seg> Integer 0-65535</seg>
                        <seg>65535</seg>
                        <seg>The high level output of the pulser</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>iolevel</seg>
                        <seg>Enumerated value</seg>
                        <seg>NIM</seg>
                        <seg>The signalling level to be used by the
                        LEMO I/O connectors.  This can be one of
                        <literal>NIM</literal> or <literal>TTL</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>errorflagmask</seg>
                        <seg>Integer 0-0xffff</seg>
                        <seg>0</seg>
                        <seg>Error flag bitmask that determines what lights
                        the front panel error LED given specific error
                        conditions</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>errorflagdatamask</seg>
                        <seg>Integer  0-0xffff</seg>
                        <seg>0</seg>
                        <seg>Error flag bitmask that determines which which error
                        conditions result in an error condition in the event.</seg>
                    </seglistitem>
                    </segmentedlist>
                    
                </section>
                <section>
                    <title>Internal Logic block parameters</title>
                    <para>
                        Triggers can be the result of sophisiticated conditions in
                        two internal logic blocks called ITLA and ITLB.
                        This set of parameters determine how those  logic blocks
                        function.  Because there are two logic blocks, These
                        parameters are  mostly in pairs, on parameter for ITLA
                        and a second for ITLB
                    </para>
                    <segmentedlist>
                        <title>
                        </title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>itlalogic, itlblogic</seg>
                        <seg>Enumerated value</seg>
                        <seg>OR, OR</seg>
                        <seg>
                            Determines how the channel inputs to the
                            ITLA/ITLB logic blocks are interpreted to
                            create a trigger output from that block.
                            Options are:
                            <literal>
                              OR, AND, Majority
                            </literal>
                            Note that if <literal>Majority</literal>  is selected,
                            <literal>itlxmarjoritylevel</literal> determines the
                            actual majoriy level required.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlamajoritylevel, itlbmajoritylevel</seg>
                        <seg>Integeer 1-63</seg>
                        <seg>1</seg>
                        <seg>The majority level for the specified trigger
                        gropu.  Note this is only relevant if the corresponding
                        trigger block is functioning in <literal>Majority</literal>
                        mode.</seg>
                        
                    </seglistitem>
                    <seglistitem>
                        <seg>itlapairlogic, itlbparilogic</seg>
                        <seg>Enumerated value</seg>
                        <seg>None, None</seg>
                        <seg>
                            Adjacent channel pairs (0,1 2,3 etc.) can be combined
                            as inputs to the ITLA or ITLB logic blocks. These
                            parameters determine if and how those pairs are combined.
                            When combined, both outputs of the pair will be the
                            ouptput of the logic function applied (e.g. if in AND
                            mode and only channel 0 triggers, then both inputs 0 and 1
                            will be in the untriggered state as inputs to the logic block).
                            Possible values are:
                            <literal>
                                AND, OR, NONE
                            </literal>  Where <literal>AND</literal> as well as
                            <literal>OR</literal> combine the inputs into a paired
                            while <literal>NONE</literal> passes the inputs to their
                            corresonding outputs without any pair logic.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlapolarity, itlbpolarity</seg>
                        <seg>Enumerated value</seg>
                        <seg>Direct, Direct</seg>
                        <seg>Determines the output polarity of the specified
                        trigger logic block.
                        This can be either <literal>Direct</literal>
                        or <literal>Inverted</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlamask, itlbmask</seg>
                        <seg>Integer 0 - 0xffffffffffffffff</seg>
                        <seg>0xffffffffffffffff, 0xffffffffffffffff</seg>
                        <seg>This mask has a bit for each channel, if set that channel
                        participates in the associated internal trigger logic block.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlagatewidth, itlbgatewidth</seg>
                        <seg>Integer nanoseconds 0-524280</seg>
                        <seg>100, 100</seg>
                        <seg>The ITLA and ITLB outputs are inputs to gate generators.
                        These parameters determine the width of the output of that
                        gate generator in ns.</seg>
                    </seglistitem>
                    </segmentedlist>
                    
                </section>
                <section>
                    <title>LVDS Options</title>
                    <para>
                        The 16 LVDS I/Os can be programmed in a sets of four (quartets).
                        The parameters in this section describe how to configure them.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>lvdsmode</seg>
                            <seg>List of 4 enumerated values</seg>
                            <seg>[lrepeat IORegister 4]</seg>
                            <seg>
                                Determines the functionality of each of the four
                                quartets of LVDS I/Os:
                                <literal>SelfTriggers, Sync, IORegister</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdsdirection</seg>
                            <seg>List of four enumerate valus</seg>
                            <seg>[lrepeat Output 4]</seg>
                            <seg>Determines the direction of each of the four
                            quartests of LVDS I/Os: <literal>Input, Output</literal></seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdstrgmask</seg>
                            <seg>List of 16 integer values 0 - 0xffffffffffffffff</seg>
                            <seg>[lrepeate 0 16]</seg>
                            <seg>If a quartet is in <literal>SelfTriggers</literal>
                            mode as an <literal>Output</literal>, these masks
                            determine which self triggers are associated with each pin
                            of the LVDS output in that quartet.  There are 16 elements
                            corresponding to each of the 16 LVDS I/O pins. If
                            a pin is not in a quartet that is configured as
                            a <literal>SelfTriggers</literal> <literal>Output</literal>
                            it's mask is ignored.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdsoutput</seg>
                            <seg>Integer 0-0xffff</seg>
                            <seg>0</seg>
                            <seg>
                                If a pin is part of a quartet that's configured for
                                <literal>IORegister</literal>, <literal>Output</literal>,
                                The corresponding bit of this mask determines the
                                value of that pin.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>DAC  options</title>
                    <para>
                        Each module has a dedicated Digital to Analog Converter
                        (DAC).  The <literal>DAC</literal> LEMO output on the
                        module front panel reflects the output of this device.
                        These parameters control what that is.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>dacoutmode</seg>
                            <seg>Enumerated Value</seg>
                            <seg>ChSum</seg>
                            <seg>Determines what the input to the DAC is.
                            Legal values are
                            <literal>
                                Static, IPE, ChInput, MemOccupancy, ChSum, OverThrSum,
                                Ramp, Sin5MHz, Square
                            </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dacoutputlevel</seg>
                            <seg>Integer 0-16383</seg>
                            <seg>0</seg>
                            <seg>
                                If the output mode is <literal>Static</literal>,
                                the output is the DAC conversion of this value
                                as its input.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dacoutchannel</seg>
                            <seg>integer 0-63</seg>
                            <seg>0</seg>
                            <seg>If the DAC output mode is
                            <literal>ChInput</literal> this value selects the
                            channel input that is echoed on the DAC output.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Input conditioning</title>
                    <para>
                        Describes the parameters that control the relationship
                        between the raw ADC inputs and what the digitizers see.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>vgagain</seg>
                            <seg>List of four integers 0-40</seg>
                            <seg>0</seg>
                            <seg>If the module is equipped with variable gain
                            amplifiers on its input, each amplifier gain is common
                            between 16 inputs.  This list of parameters sets the
                            VGA Gain for groups of 16 channels.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>offsetcalibrationenable</seg>
                            <seg>Boolean value</seg>
                            <seg>true</seg>
                            <seg>Enable/disable the offset calibraion for each channel.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>channelenables</seg>
                            <seg>List of 64 booleans</seg>
                            <seg>[lrepeat true 64]</seg>
                            <seg>
                                For each channel when its corresponding list element
                                is true, the channel is enabled, otherwise it is
                                disabled.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dcoffsets</seg>
                            <seg>List of 64 floats 0-100.0</seg>
                            <seg>[lrepeat 50.0 64]</seg>
                            <seg>For each channel, this is the DC Offset applied
                            to the channels.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>triggerthresholds</seg>
                            <seg>64 element list of integers 0-8191</seg>
                            <seg>1023</seg>
                            <seg>
                                Channel trigger thresholds.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>inputpolarities</seg>
                            <seg>list of 64 enums</seg>
                            <seg>[lrepeat Negative 64]</seg>
                            <seg>Sets the polarity of the input pulse for each channel.
                            Valid values are <literal>Positive</literal>
                            and <literal>Negative</literal></seg>
                        </seglistitem>
                    </segmentedlist>
                                           
                </section>
                <section>
                    <title>Event Selection Options</title>
                    <para>
                        The module has several post trigger event filtering options
                        that can be set.  These options are exposed as:
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>energyskimlow</seg>
                            <seg>64 element integer list 0-65534</seg>
                            <seg>[lrepeat 0 64]</seg>
                            <seg>
                                Events in a channel with computed energies
                                less than this value (for that channel) are not
                                passed to the host.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>energyskimhigh</seg>
                            <seg>64 element integer list 0-65534</seg>
                            <seg>[lrepeat 65534 64]</seg>
                            <seg>
                                Events in a channel with computed energies
                                higher than this value (for that channel) are not
                                passed to the host. Thus the <literal>energyskimlow</literal>
                                and <literal>energyfilterhigh</literal> values
                                for each channel provide an energy cut between
                                which events are accepted and outside of which
                                they are rejected.  See, however
                                <literal>eventselector</literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>eventselector</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat All 64</seg>
                            <seg>
                                Selects which events (energy values) are
                                saved for each channel. Valid values for each
                                element of the list are
                                <literal>All, Pileup, EnergySkim</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>waveselector</seg>
                           <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat All 64</seg>
                            <seg>
                                Selects which waveforms are
                                saved for each channel. Valid values for each
                                element of the list are
                                <literal>All, Pileup, EnergySkim</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>coincidencemask</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat Disabled 64]</seg>
                            <seg>
                                Defines a concidence source for a trigger on each
                                channel.  Valid values are:
                                <literal>
                                    Disabled, Ch64Trigger, TRGIN,
                                    GlobalTriggerSource, ITLA, ITLB
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>anticoincidencemask</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeate Disabled 64</seg>
                            <seg>
                                Defines an anticoincidence source for a trigger
                                on each channel.  Valid values are:
                                <literal>
                                    Disabled, Ch64Trigger, TRGIN,
                                    GlobalTriggerSource, ITLA, ITLB
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>coincidencelength</seg>
                            <seg>List of 64 integer values in nanoseconds 8-524280</seg>
                            <seg>[lrepeat 100 64</seg>
                            <seg>
                                Defines, for each channel, the coincidence window
                                in nanoseconds for the coincidence and anti
                                coincidence trigger sources defined by
                                <literal>coincidencemask</literal>
                                and <literal>anticoincidencemask</literal>.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>DPP Processing parameters</title>
                    <para>
                        Firmware on the module processes raw, digitized wave forms
                        into pulse heights (energies).  This processing includes a
                        time filter and an energy filter.  The parameters
                        in this section are relevant to those two filters.
                    </para>
                    <para>
                        Figure 3  of the <literal>FELib PHA Parameters User Manual</literal>
                        is a useful description of these parameters and how they
                        drive signal processing.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>tfrisetime</seg>
                            <seg>64 element list of integers 4-250</seg>
                            <seg>[lrepeate 80 64]</seg>
                            <seg>
                                The rise time parameter for the time
                                fiter for each channel
                                expressed in digitizer samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>tfretriggerguard</seg>
                            <seg>64 element list of integers 0-1000</seg>
                            <seg>[lrepeat 0 64]</seg>
                            <seg>
                                The time filter retrigger guard for each
                                channel expressed in samples. 
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efrisetime</seg>
                            <seg>64 element list of integers 4-1625</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                The rise time parameter of the enegy filter
                                for each channel expressed in samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efflattoptime</seg>
                            <seg>64 element list of integers 4-375</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                The energy filter flattop time parameter
                                in units of samples for each channel.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpeakingpos</seg>
                            <seg>64 element list of integers 10-90</seg>
                            <seg>[lrepeat 50 64]</seg>
                            <seg>
                                The trapezoid peaking position for each channel
                                in percentage of the flattop time.  Note the
                                manual, at the time I'm writing this erroneously
                                expresses the limis on this parameter
                                at 0-100. 
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpeakingavg</seg>
                            <seg>list of 64 enumerated values</seg>
                            <seg>[lrepeat 1 64]</seg>
                            <seg>
                                Number of samples averaged to evaluate the
                                peak for each channel.  Legal values are
                                <literal>
                                    1, 4, 16, 64
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpolezero</seg>
                            <seg>list of 64 integers 4-65500</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                Pole zero adjustment of the digital shaping
                                amplifier for each channel in units of samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>effinegain</seg>
                            <seg>list of 64 floating point values 1.0-10.0</seg>
                            <seg>[lrepeat 1.0 64]</seg>
                            <seg>
                                Sets the digital fine gain for each channel.
                                The granularity of these values is
                                0.001.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>eflflimitation</seg>
                            <seg>64 element list of bools</seg>
                            <seg>[lrepeat false 64]</seg>
                            <seg>
                                When enabled for a channel, a low frequency
                                filter is applied to that channel for the
                                energy filter.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efbaselineavg</seg>
                            <seg>64 element list of enumerated values</seg>
                            <seg>[lrepeat 16 64]</seg>
                            <seg>
                                The number of samples averaged to compute the
                                signal baseline prior to the start of the
                                trapezoidal filter.  Legal values for each
                                element are:
                                <literal>0, 16, 64, 256, 1024, 4096, 16384</literal>.
                                Note that a value of <literal>0</literal>
                                fixes the baseline at zero.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
            </section>
        </section>
        <section id='sec.eventstruct'>
            <title id='sec.eventstruct.title'></title>
            <para>
                To be written.
            </para>
        </section>
    </chapter>
    <chapter id='ch.spectcl'>
        <title id='ch.spectcl.title'>
            Configuring SpecTcl
        </title>
        <para>
            To Be written
        </para>
    </chapter>
    <appendix id='app.internals'>
        <title>Software structure</title>
        <para>To Be written</para>
    </appendix>
    <appendix>
        <title>Class reference</title>
        <para>
            To Be written
        </para>
    </appendix>
</book>