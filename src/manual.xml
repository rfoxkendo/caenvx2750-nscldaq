<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>NSCLDAQ support for the CAEN VXxxxx series of digitizers with DPP-PHA.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>October 7, 2022</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
      <corpcredit>CAEN Technologies</corpcredit>
      <address><email>ron@caentechnologies.com</email></address>
    </bookinfo>
    <chapter id='ch.intro'>
        <title>Introduction</title>
        <para>
            This document describes how to configure and use the NSCLDAQ support
            for the new generation of CAEN VXxxxx digitizers.  I assume that:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  You have a basic familiarity with NSCLDAQ, how to configure it
                  and how to use its event builder.
               </para>
            </listitem>
            <listitem>
               <para>
                  You have a basic familiarity with how to use and tailor
                  the SpecTcl analysis package (if you choose to use this
                  for analysis).
               </para>
            </listitem>
            <listitem>
               <para>
                  You are familiar with the configuration parameters of the
                  DPP-PHA firmware supported by these modules.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that NSCLDAQ and SpecTcl documentation are all online at
            <ulink url='http://docs.nscl.msu.edu/daq' />.   Problems and questions
            about NSCLDAQ and SpecTcl (outside the scope of the CAEN Vxxxx digitizers)
            should be addressed to <ulink url='mailto:helpme@frib.msu.edu' />.
        </para>
        <para>
            The document is therefore organized into the following chapters:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  <link linkend='ch.readout' endterm='ch.readout.title'/> describes
                  how to create and configure a customized Readout program which
                  will inject data from a set of ADCs into the NSCLDAQ data flow
                  system.   Within that chapter,
                  <link linkend='sec.rdoprogramming' endterm='sec.rdoprogramming.title' />
                  describes the changes needed to the SBS readout skeleton.  The
                  format of events readout by this program will also be described.
                  <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />
                  describes how the modules are configured and how to write a
                  configuration file for your readout software.
               </para>
            </listitem>
            <listitem>
               <para>
                   <link linkend='ch.spectcl' endterm='ch.spectcl.title' />
                   describes how to build a tailored version of SpecTcl to produce
                   raw parameters from the modules  you are reading out. 
               </para>
            </listitem>
        </itemizedlist>
        <para>
            For those interested an appendix describes the structure of the software
            as well as items for further development.
        </para>
        <para>
            The <filename>tclreadout</filename> subdirectory of the source tree
            gives a sample tailored readout program for the readout software
            described in <link linkend='ch.readout' endterm='ch.readout.title' />.
            The <filename>tclreadout/SpecTcl</filename> subdirectory of the source
            tree gives a sample tailored SpecTcl program for this example.
        </para>
    </chapter>
    <chapter id='ch.readout'>
        <title id='ch.readout.title'>Getting Data</title>
        <para>
            Data is read from modules using a tailored SBS readout program that
            makes use of classes that have been written to support the new
            CAEN VXxxxx digitizers and DPP-PHA firmware.   These modules have
            a huge number of settable parameters.
        </para>
        <para>
            To manage the settable parameters, each module is associated with a
            <firstterm>configuration</firstterm>.  The module's configuration
            captures the desired settings for that module.  A module is assigned
            a name by your software and a matching named configuration is  read
            and used to configure that module at the start of each run.  The
            configuration is re-read each begin run so that changes can be made
            between runs.
        </para>
        <para>
            <link linkend='sec.rdoprogramming' endterm='sec.rdoprogramming.title' />
            describe how to tailor an SBS readout skeleton to produce a readout
            program.   <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />
            describes how to create module configurations and the parameters
            that can be set for a module.
        </para>
        <para>
            A few notes:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  While the software was developed with 12.0-pre, I believe the
                  support software will function with 11.3 as well.
               </para>
            </listitem>
            <listitem>
               <para>
                  Since each module is assigned a source id, when event building
                  the readout program should be run with the
                  <option>--no-barriers</option> optioon in order to prevent
                  the event builder from stalling on a barrier wait at the start
                  and end of runs.
               </para>
            </listitem>
        </itemizedlist>
        <section id='sec.rdoprogramming'>
            <title id='sec.rdoprogramming.title'>Obtaining and modifying the skeleton</title>
            <para>
                The Readout is based on the SBS readout skeleton.  This
                software allows for an experiment specific trigger which causes
                experiment specific code to be run.  SBS readout skeletons, therefore
                require tailoring to fit specific applications.

            </para>
            <para>
                Here are the steps required to tailor that system for the
                CAEN modules:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Select the version of NSCLDAQ you will use, and source in its
                      setup file to define environment variables that will make
                      your life easier.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Obtain a copy of the sbs skeleton in an emtpy directory. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Make appropriate modifications to the
                      <filename>Skeleton.cpp</filename>'s
                      <methodname>Skeleton::SetupReadout</methodname> method
                      to define the modules you will be using.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Modify the Makefile provided with the skeleton to pull in the
                      libraries and headers that make up support.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Build the Readout program. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Write a configuration file that appropriately configures
                      each module you defined (covered in
                      <link linkend='sec.rdoconfig' endterm='sec.rdoconfig.title' />).
                   </para>
                </listitem>
            </orderedlist>
            <para>
                The remainder of this section assumes you have selected
                NSCLDAQ-12.0-pre5.    To obtain that skeleton:
            </para>
            <example>
                <title>
                    Selecting DAQ version and obtaining the skeleton:
                </title>
                <programlisting>

source /usr/opt/daq/12.0-pre5/daqsetup.bash
mkdir myreadout
cd myreadout
cp $DAQROOT/skeletons/sbs/* .

                </programlisting>
            </example>
            <section>
                <title>Modifying the Skeleton</title>
                <para>
                    In this example, the key class is:
                    <classname>TclConfiguredReadout</classname> is a container
                    class that is an <firstterm>CEventSegement</firstterm> that
                    holds a set of modules to readout and constructs and appropriate
                    trigger to drive the readout.  It will also construct
                    and maintain objects for each module.
                </para>
                <para>
                    Construction specifies a configuration file that is processed
                    at the beginning of each run and used to program the
                    configuration of each module.
                </para>
                <para>
                    The class's <methodname>addModule</methodname> method
                    creates a module driver for a module, providing the connection
                    parameters for that module and associating it with a module
                    configuration within the configuration file. Each module,
                    so defined must be assigned a source id that is unique
                    across the system.  This source Id is used in event building.
                </para>
                <para>
                    Here are the parameter signatures for the methods you need
                    to use:
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>TclConfiguredReadout</methodname>
                            <methodparam>
                                <type>const char*</type><parameter>configfile</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CExperiment*</type><parameter>pExperiment</parameter>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>configfile</parameter> is the
                            path to a file that describes configurations for each
                            module that will be added to this event segment
                            (see <methodname>addModule</methodname>).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void</type>
                          <methodname>addModule</methodname>
                          <methodparam>
                              <type>const char*</type><parameter>name</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const char*</type><parameter>connectionString</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::uint32_t</type><parameter>sid</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool</type><parameter>isusb</parameter>
                              <initializer>false</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                                Adds a module to the readout.  <parameter>name</parameter>
                                is the name of a module in the configuration
                                file specified in the construtor.
                           </para>
                           <para>
                            <parameter>connectionString</parameter> is a string
                            that describes how the module is connected to the system.
                            This string is either a dotted IP address (e.g
                            "127.0.0.1") if ETHERNET is used or the PID of the module
                            if USB is used.  Note that DNS lookups are not done for
                            host names but there is nothing to stop you from doing
                            host lookups yourself prior to calling
                            <methodname>addModule</methodname>
                           </para>
                           <para>
                            <parameter>sid</parameter> is a unique integer source id
                            that identifies this module to the event builder.
                           </para>
                           <para>
                            <parameter>isUsb</parameter> is an optional parameter
                            that defaults to <literal>false</literal>.
                            If <literal>true</literal>, it specifies that the
                            <parameter>connectionString</parameter> is a module PID
                            and that the connection is via USB.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>CTrigger*</type>
                          <methodname>getTrigger</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the trigger that the object
                            has computed for the modules that have been added to it.
                            This should be used to supply a trigger object to the
                            Readout program framework.
                           </para>
                        </listitem>
                    </varlistentry>

                </variablelist>
                                <para>
                    Let's look at a simple example.  The full example is in
                    the <filename>tclreadout</filename> subdirectory of the
                    source tree.  If you want to use that as a starting point,
                    simply modify the <literal>INSTDIR</literal> definition
                    at the top of the file to point to the version of NSCLDAQ
                    you decided to use.
                </para>
                <example id='ex.skeleton'>
                    <title id='ex.skeleton.title'>Sample Skeleton.cpp modifications</title>
                    <programlisting>
#include &lt;config.h&gt;
#include &lt;Skeleton.h&gt;
#include &lt;CExperiment.h&gt;
#include &lt;TCLInterpreter.h&gt;
#include &lt;CTimedTrigger.h&gt;
#include &lt;TclConfiguredReadout.h&gt;   <co id='rdo.classinc' />
#include &lt;Dig2Device.h&gt;             <co id='rdo.tracinginc' />

...

void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
 
  CReadoutMain::SetupReadout(pExperiment);
  
  // turns on felib tracing if compiled with it enabled

  // caen_nscldaq::set_tracing(true);    <co id='rdo.tracing' />
  
  // First we create a TclConfiguredReadout object and describe the
  // connections to the modules in the system -- assigning each
  // module a distinct source id for event building.
  // Note that the event builder allows fragments from the same source to get
  // grouped into the same event and each fragment is tagged with its channel..
  // so per-module sids rather than per-channel work just fine:
  
  auto pSegment = new TclConfiguredReadout(   <co id='rdo.makesegment'/>
    "configuration.tcl",            // Detailed module settings file path.
    pExperiment                     // Pointer to experiment object.
  );
  pSegment-&gt;addModule(                    <co id='rdo.addmodule' />
    "adc1",                   // Name of module in configuration.tcl
    "15236",                   // PID for USB connection, IP If ethernet.
    1,                        // System unique source id.
    true                      // Indicates it's USB not Ethernet defaults to false.
  );
  
  pExperiment-&gt;AddEventSegment(pSegment);   <co id='rdo.registersegment' />
  
  // The event segment creates a dynamic multi trigger object which we need
  // to fetch out and register as the trigger for the system:
  
  pExperiment-&gt;EstablishTrigger(pSegment->getTrigger()); <co id='rdo.registertrigger' />
  
}


                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='rdo.classinc' >
                        <para>
                            This <literal>#include</literal> is needed to define
                            the <classname>TclConfiguredReadout</classname>
                            class.
                        </para>
                    </callout>
                    <callout arearefs='rdo.tracinginc' >
                        <para>
                            Wrappers for the CAEN libraries support tracing the
                            operations and responses performed on the module.
                            This header provides definitions needed to enable
                            this tracing.  Note that tracing must be enabled both
                            programmatically and via a compilation option in the
                            library Makefile.
                        </para>
                    </callout>
                    <callout arearefs='rdo.tracing' >
                        <para>
                            If the library has been built with tracing enabled,
                            uncommenting this line will turn that on. Note that this
                            will create a large trace file, as well as adversely
                            impact performance.
                        </para>
                    </callout>
                    <callout arearefs='rdo.makesegment' >
                        <para>
                            Creates the <classname>TclConfiguredReadout</classname>
                            object that will manage the modules we will use.
                            At the start of each run, <filename>configuration.tcl</filename>
                            will be processed to load the configuration for each
                            module and each module will then be asked to configure itself
                            in accordance with its configuration.  The
                            <parameter>pExperiment</parameter> pointer passed in
                            to <methodname>SetupReadout</methodname> points to
                            an object that provides services needed.
                        </para>
                        <para>
                            Note that <methodname>SetupReadout</methodname> is only
                            called once at system startup and the lifetime of the
                            <classname>TclConfiguredReadout</classname> will be
                            the lifetime of the Readout program.  Therefore,
                            the fact that the <varname>pSegment</varname>
                            never is deleted is not a memory leak.
                        </para>
                    </callout>
                    <callout arearefs='rdo.addmodule' >
                        <para>
                            Adds a module to the system.  The module is named
                            <literal>adc1</literal> and will, therefore expect
                            a configuration for <literal>adc1</literal>.
                            It is a USB connected module with PID 
                            <literal>15236</literal> and is assigned source id
                            <literal>1</literal>.
                        </para>
                        <para>
                            The <classname>TclConfiguredReadout</classname>
                            will manage this module from now on.  It will also
                            produce a part of the readout trigger based
                            on data being available in this module.
                        </para>
                    </callout>
                    <callout arearefs='rdo.registersegment' >
                        <para>
                            The <classname>TclConfiguredReadout</classname>
                            event segment is registered with the experiment framework
                            so that its methods will be invoked by that framework
                            when appropriate.
                        </para>
                    </callout>
                    <callout arearefs='rdo.registertrigger' >
                        <para>
                            The trigger computed by the
                            <classname>TclConfiguredReadout</classname> event
                            segment is fetched and established as the trigger
                            for readout.  When a run is active this trigger is
                            polled and, when it indicates that it has been
                            triggered, readout will ensue.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Modifying the Makefile and Building Readout</title>
                <para>
                    The CAEN digitizer support software (NSCLDAQ and base).  The
                    SBS skeleton readout Makefile must be edited to ensure that
                    appropriate include directories are searched when compiling
                    and libraries pulled in when linked:
                </para>
                <itemizedlist>
                    <listitem>
                       <para>
                          <literal>-lCAEN_FELib</literal>  must be added
                          to the definition of <varname>USERLDFLAGS</varname>
                          This links in the base CAEN library that provides
                          support for communicating with the digitizer.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          JavaScript Object Notation (JSON) is used to specify readout formats and a JSON
                          support library (JSONCPP) is used to format those requests.
                          This is a package that's installed in the containers
                          we distribute or, if you are running native, is a
                          debian package: <literal>libjsoncpp-dev</literal>
                          Due to headers that are included by other headers,
                          <literal>$(shell pkg-config jsoncpp --cflags)(</literal>
                          must be added to <varname>USERCCFLAGS</varname>
                          and <literal> $(shell pkg-config jsoncpp  --libs)</literal>
                          added to <varname>USERLDFLAGS</varname>
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Tracing FE library calls is done via the boost logging
                          package so
                          <literal>-lboost_log -lboost_log_setup  -lboost_thread -lboost_syste</literal>
                          must be added to <varname>USERLDFLAGS</varname>.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                           Finally we need to pull in the NSCLDAQ support
                           library.  Suppose the headers are all installed in
                           <literal>$(CAEN_NSCLDAQ)/include</literal> and
                           libraries in <literal>$(CAEN_NSCLDAQ)/lib</literal>.
                           <literal>-I$(CAEN_NSCLDAQ)/include</literal>
                           must be added to <varname>USERCCFAGS</varname> and
                           <literal>-L$(CAEN_NSCLDAQ)/lib -lCaenVx2750</literal>
                           to <varname>USERLDFLAGS</varname>
                       </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Once this has been done, the Readout program can be built
                    via <command>make</command>
                </para>
            </section>
        </section>
        <section id='sec.rdoconfig'>
            <title id='sec.rdoconfig.title'>Configuring modules</title>
            <para>
                Each module must be configured to be useful.  This is done by
                writing a configuration script.  Configuration scripts are
                written in a domain specific language layered on top of the
                Tcl scripting language.  Tcl is extended by adding a single command
                ensemble: <command>v27xxpha</command> to Tcl. 
            </para>
            <para>
                A command ensemble in Tcl parlance is a single command that has
                subcommands specified by the next word on the command line.  The
                <command>v27xxpha</command> command has the following forms:
            </para>
            <variablelist>
                <varlistentry>
                   <term><command>vx27xxpha create <replaceable>module-name</replaceable></command></term>
                   <listitem>
                       <para>
                        Creates a new configuration for a module <parameter>module-name</parameter>.
                        When the Readout initializes modules it looks for configurations
                        that match the names of modules that have been added
                        to the <classname>TclConfiguredReadout</classname>
                        module.
                       </para>
                       <para>
                        thus in our example
                        <link linkend='ex.skeleton' endterm='ex.skeleton.title' />
                         <command>vx27xxpha create adc1</command> would create
                         a configuration for the module we added.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha config <replaceable>module-name name value ...</replaceable></command></term>
                   <listitem>
                       <para>
                        Configures one or more parameter values for the
                        <parameter>module-name</parameter>.  Any number of
                        parameter name/value pairs can be specified on the command.
                        For example:
                        <command>v27xxpha config adc1 dcoffsets [lrepeat 64 0]</command>
                        Configures the DC offsets for all 64 channels to be 0% of
                        full scale.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha cget <replaceable>module-name name</replaceable></command></term>
                   <listitem>
                       <para>
                        This command returns the value of the parameter
                        <parameter>name</parameter> from the configuration
                        for the module <parameter>module-name</parameter>.
                        For example:
                        <command>puts [vx27xxpha cget adc1 dcoffsets]</command>
                        will print 64 zeroes to stdout.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx27xxpha delete <replaceable>module-name</replaceable></command></term>
                   <listitem>
                       <para>
                        Really not necessary - this deletes the configuration
                        for <parameter>module-name</parameter>.  Since the
                        configuration file is processed and all configuration rebuilt
                        from scratch at each begin run,
                        there's really no need to delete modules.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><command>vx25x0 list</command></term>
                   <listitem>
                       <para>
                        Returns a list of the module names that have configurations.
                        the following little script will list the modules
                        configured, one per line to stdout:
                       </para>
                       <informalexample>
                        <programlisting>
foreach module [vx27xxpha list] {
    puts $module
}
                        </programlisting>
                       </informalexample>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                A sample configuration file that goes along with the
                sample readout program in the <filename>tclreadout</filename>
                subdirectory of the source tree is 
                <filename>/configuration.tcl</filename>.
            </para>
            <section>
                <title>Configuration parameter reference</title>
                <para>
                    This section consists of several subsections.  Each
                    subsection provides a reference for a set of configuration
                    parameters that are related in some way.
                    Parameters are describes as follows:
                </para>
                <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem><seg>Name of the parameter</seg>
                    <seg>Data type the item must be</seg>
                    <seg>Defeault value for the item</seg>
                    <seg>Description of the item.</seg>
                    </seglistitem>
                </segmentedlist>
                <para>
                    A note on the boolean data type.  Any of the following are
                    valid true values:
                    <literal>true, yes, 1, on, enabled</literal>, while any
                    of the following are valid false value
                    <literal>false, no, 0, off, disabled</literal>.
                </para>
                <para>
                    A note on integer data types.  These can be expressed in base
                    10, 16 or 8. Base 16 values should be prefixed by 0x,
                    e.g. <literal>0x5a5a5a5a5a5a5a5a</literal>.  Base 8 values
                    are prefixed by a leading zero e.g. 0777.
                    
                </para>
                <warning>
                    <title>WARNING</title>
                    <para>
                        Do not use leading zeros to align decimal values,
                        they will be treated as octal and, in general,
                        not have the intended effect.  This is a curse that has
                        afflicted many a user of the Tcl language.
                    </para>
                </warning>
                <para>
                    When in doubt about the meaning of a parameter see CAEN
                    document
                    <literal>UM7788 --FELib PHA Parameters User Manual</literal>.
                </para>
                <section>
                    <title>Readout Options</title>
                    <para>
                        The parameters in this section are not actually digitizer
                        parameters, the determine what is read from the
                        digitizer at each event.  All events will read the
                        event channel number, timestamp in nanosecods
                        and energy from the DPP-PHA.
                        These options allow additional available parameters/features
                        to be read from the digitizer.
                    </para>
                    <para>
                        The configuration parameters are:
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>readrawtimes</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the raw time stamp counter is included
                        in each event.  Note that the nanosecond timestamp
                        is always used for even building as the raw timestamp
                        may vary in frequency depending on the digitizer.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readfinetimestamps</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, and if the module supports the generation
                        of fine timing information (e.g. interpolated timing from
                        a CFD), turning this on enables the inclusion of that fine
                        timing information in the event.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readflags</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled reads various bits that report on the
                        digitizer's state</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readtimedownsampling</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, reads a code that corresponds to the
                        digitizer sampling scaledown</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readanalogprobes</seg>
                        <seg>list of two booleans</seg>
                        <seg>{false false}</seg>
                        <seg>The module supports two analog probes these can be used
                        to acquire the input waveforms as well as various diagnostic
                        information.  The first element of the list enables/disables
                        the inclusion of analog probe1 and the second the inclusion of
                        analog probe 2</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readdigitalprobes</seg>
                        <seg>list of four booleans</seg>
                        <seg>{false false false false}</seg>
                        <seg>The digitizer supports the inclusion of four digital probes.
                        A digital probe has a byte per sample with a value of 0 or
                        1.  The list can selectively enable the inclusion of data
                        from each probe.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readsamplecount</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the number of samples read for this
                        channel are included.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>readeventsize</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If enabled, the raw event size is read.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>General options</title>
                    <para>
                        These parameters control general module wide functionality.
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>clocksource</seg>
                        <seg>Enumerated</seg>
                        <seg><literal>Internal</literal></seg>
                        <seg>Selects the source of the digitizer's clock.
                        Valid values are <literal>Internal</literal>
                        to use the module's internal clock or
                        <literal>FPClkIn</literal> to use the front panel clock
                         input.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>outputfpclock</seg>
                        <seg>boolean</seg>
                        <seg>false</seg>
                        <seg>If <literal>true</literal>, the digitizer clock is output
                        on the front panel.  This allows modules to use a single
                        shared clock source without needed an external clock.
                        Clock delays can then compensate for clock propagation
                        delays as one progresses  down the clock in/clock out
                        daisy chain.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Triggerring and I/O</title>
                    <para>
                        The parameters control digitizer and channel level triggers
                        as well as the LEMO connectors on the front panel.
                    </para>
                    <segmentedlist>
                    <title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>startsource</seg>
                        <seg>List of enumerated values</seg>
                        <seg>SWcmd</seg>
                        <seg>The list of ways the digitizer can start a run.
                        The digitzer is started on the or of the conditions
                        in the list.  Usually, in a synchronized set, the
                        'master' digitizer is stated on <literal>SWcmd</literal> and the others
                        on e.g. <literal>SINedge</literal>.   Valid values for list elements are:
                        <literal>EncodedClkIn, SINlevel, SINedge, SWcmd, LVDS, P0</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>gbltriggrsrc</seg>
                        <seg>List of Enums</seg>
                        <seg>TrgIn</seg>
                        <seg>The sources of the module global trigger.  The
                        or of the values listed makes a global trigger.
                        Valid values are
                        <literal>TrgIn, P0, SwTrg, LVDS, ITLA, ITLB,
                        ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn, GPIO,
                        TestPulse</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>wavetriggersrc</seg>
                        <seg>List of 64 lists of enums</seg>
                        <seg>[lrepeat TRGIN 64]</seg>
                        <seg>This parameter is a list of 64 trigger sources for
                        wave acquisition.  Each element of that list is itself
                        a list of triggers sources for that channel.  Valid
                        values for the trigger sources are:
                        <literal>
                            ITLB, ITLA, GlobalTriggerSource, TRGIN, ExternalInhibit,
                            ADCUnderSaturation, ADCOverSaturation, SWTrg, ChSelfTrigger,
                            Ch64Trigger, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>eventtriggersrc</seg>
                        <seg>List of 64 lists of enums</seg>
                        <seg>[lrepeat TRGIN 64]</seg>
                        <seg>Similar to the <literal>wavetriggersrc</literal>
                        but provides, for each channel a list of event trigger
                        sources.   Valid values are:
                        <literal>
                            ITLB, ITLA, GlobalTriggerSource, TRGIN, SWTrg, ChSelfTrigger,
                            Ch64Trigger, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>channeltriggermasks</seg>
                        <seg>List of 64 uint64_t</seg>
                        <seg>[lrepeat 0 64]</seg>
                        <seg>In <literal>Ch64Trigger</literal> mode, or coincidence
                        triggering mode, used to define the set of channels that
                        particpate in triggering each channel.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>savetraces</seg>
                        <seg>List of 64 enums</seg>
                        <seg>[lrepeat OnRequest 64]</seg>
                        <seg>Determines when wave traces are saved for each
                        channel.  Valid values are
                        <literal>Always, OnRequest</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>triggeroutmode</seg>
                        <seg>Enumerated value</seg>
                        <seg>TRGIN</seg>
                        <seg>Determines what is output on the <literal>TRGOUT</literal>
                        LEMO output.  Valid values are:
                        <literal>
                            TRGIN, P0, SwTrg, LVDS, ITLA, ITLB,
                            ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn,
                            Run, RefClk, TestPulse,
                            Busy, Fixed0, Fixed1, SyncIn, SIN, GPIO,
                            AcceptTrg, TrgClk
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>gpiomode</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>Selects the signal to output on the
                        GIO LEMO connector.
                        This can be one of
                        <literal>
                            Disabled, TrgIn, P0, SIN, LVDS, ITLA, ITLB,
                            ITLA_AND_ITLB, ITLA_OR_ITLB, EncodedClkIn, SwTrg,
                            Run, RefClk, TestPulse, Busy, Fixed0, Fixed1
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>busyinsrc</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>Determines the source of the external
                        module busy input.  This is one of:
                        <literal>SIN, GPIO, LVDS, Disabled</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>syncoutmode</seg>
                        <seg>Enumerated value</seg>
                        <seg>Disabled</seg>
                        <seg>
                            Determines the source of the <literal>SOUT</literal>
                            LEMO connector.  Valid values are
                            <literal>
                                Disabled, SyncIn, TestPulse, IntClk, Run
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetosrc</seg>
                        <seg>Enumerated value</seg>
                        <seg>Source of the board level trigger veto. Valid values are
                        <literal>
                            SIN, LVDS, GPIO, P0, EncodedClkIn, Disabled
                        </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetowidth</seg>
                        <seg>Integer nano-seconds 0 - 34359738360</seg>
                        <seg>200</seg>
                        <seg>Ns stretch applied to the board veto source</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>boardvetopolarity</seg>
                        <seg>Enumerated value</seg>
                        <seg>ActiveLow</seg>
                        <seg>
                            Polarity of the veto input.  One of
                            <literal>ActiveHigh, ActiveLow</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetosrc</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Disabled 64]</seg>
                        <seg>Veto sources for each of the channels.  Each list element
                        can have one of the value:
                        <literal>
                            BoardVeto, ADCOverSaturation, ADCUnderSaturation, Disabled
                        </literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetowidth</seg>
                        <seg>List of 64 integer in units of ns 0-524280</seg>
                        <seg>[list 200 64]</seg>
                        <seg>The stretch applied to each channel's veto source.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>rundelay</seg>
                        <seg>Integer nanoseconds 0-54280</seg>
                        <seg>0</seg>
                        <seg>
                            This value is used to fine tune the synchronized
                            start of multi-board data taking. When the start source
                            is true, the actual start will be delayed by the ns
                            set in this parameter.  If, for example, the start is
                            propagated via a SIN/SOUT daisy chain on the front panel, the
                            final board will be delayed by 0 ns, the next to last
                            board by the single board propagation delay and so on.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>chanvetowidth</seg>
                        <seg>boolean</seg>
                        <seg>true</seg>
                        <seg>When true, the module is disarmed when data taking is
                        stopped.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>volclkoutdelay</seg>
                        <seg>Floating point ps -18888.8888 - 18888.8888</seg>
                        <seg>0.0</seg>
                        <seg>
                            Sets the value that is programmed into the clock PLL
                            delay.  This is used to synchronize clocks passed between
                            boards via the CLKOUT/CLKIN daisy chain.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>permclkoutdelay</seg>
                        <seg>volclkoutdelay</seg>
                        <seg>Floating point ps -18888.8888 - 18888.8888</seg>
                        <seg>0.0</seg>
                        <seg>
                            Sets the value that is programmed into the clock PLL
                            delay on power up.  This is used to synchronize clocks passed between
                            boards via the CLKOUT/CLKIN daisy chain.  Note that
                            this value is first programmed and then the volclkoutdelay
                            which actually controls the clock delay.
                            In a future bit of development a parameter migth be
                            added to select which of these two values controls
                            the actual clock delay.
                        </seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Wave form inspection and digital probes.</title>
                    <para>
                        Note that whlie the waveform and digital probe values are
                        programmed here, in order to actually include those
                        probes in the data read from the digitizer,
                        <literal>readanalogprobes</literal> and/or
                        <literal>readdigitalprobes</literal> must be set
                        accordingly.
                    </para>
                    <segmentedlist><title></title>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>wavesource</seg>
                        <seg>List of enumerated values</seg>
                        <seg>[lrepeat ADC_DATA 64]</seg>
                        <seg>
                            This is a list of one entry per channel that describes
                            what the FADC for that channel sees on its input.
                            Valid values are:
                            <literal>
                                ADC_DATA, ADC_TEST_TOGGLE, ADC_TEST_RAMP,
                                ADC_TEST_SIN, IPE,
                                 Ramp, SquareWave, ADC_TEST_PRBS
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>recordsamples</seg>
                        <seg>List of 64 integers 4-8100</seg>
                        <seg>[lrepeat 4 64]</seg>
                        <seg>Each element determines the number of samples that
                        channel of the ADC will process/record.  The actual time
                        represented depends on the value of the <literal>saveresolutions</literal>
                        parameter for that channel.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>waveresolutions</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Res8 64]</seg>
                        <seg>For each channel, selects the sampling resolution in
                        nanoseconds.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>analogprobe1, analogprobe2</seg>
                        <seg>List of 64 enumerated values</seg>
                        <seg>[lrepeat ADCInput 64], [lrepeat TimeFilter 64]</seg>
                        <seg>
                            For each channel, the analog probes available
                            for acquisition from that channel.   Allowed values
                            are:
                            <literal>
                                ADCInput, TimeFilter, EnergyFilter,
                                EnergyFilterBaseline,
                                EnergyFilterMinusBaseline
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>digitalprobe1, digitalprobe2, digitalprobe3, digitalprobe4</seg>
                        <seg>list of 64 enumerated values</seg>
                        <seg>[lrepeat Trigger 64], [lrepeat TimeFilterArmed 64],
                        [lrepeat RetriggerGuard 64],
                        [lrepeat EneryFilterBaselineFreeze 64]</seg>
                        <seg>
                            For each channel, the digital probes available for
                            acquisition from that channel.  Valid values are:
                            <literal>
                                Trigger, TimeFilterArmed, ReTriggerGuard,
                                EnergyFilterBaselineFreeze,
                                EnergyFilterPeaking, EnergyFilterPeakReady,
                                EnergyFilterPileUpGuard, EventPileup, ADCSaturation,
                                ADCSaturationProtection, PostSaturationEvent,
                                EnergyFilterSaturation,
                                AcquisitionInhibit
                            </literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>pretriggersamples</seg>
                        <seg>List of 64 integers 4-4000</seg>
                        <seg>[lrepeat 100 64]</seg>
                        <seg>For each channel, the number of samples
                        prior to the trigger that will be acquired and
                        analyzed by the DPP-PHA firmware.</seg>
                    </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Service options</title>
                    <para>
                        These, for the most part, have to do with the test pulser.
                        There are also miscellaneous parameters to control
                        error handling and the LEMO I/O levels.
                    </para>
                    <segmentedlist>
                        <title></title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>testpulserperiod</seg>
                        <seg>Integer ns 0-34359738360</seg>
                        <seg>100000</seg>
                        <seg>The period of the test puler in ns.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulsewidth</seg>
                        <seg>Integer ns 0-34359738360</seg>
                        <seg>1000</seg>
                        <seg>Width of the high part of the test pulser
                        period.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulselowlevel</seg>
                        <seg>Integer 0-65535</seg>
                        <seg>0</seg>
                        <seg>The low level output of the pulser</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>testpulsehighlevel</seg>
                        <seg> Integer 0-65535</seg>
                        <seg>65535</seg>
                        <seg>The high level output of the pulser</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>iolevel</seg>
                        <seg>Enumerated value</seg>
                        <seg>NIM</seg>
                        <seg>The signalling level to be used by the
                        LEMO I/O connectors.  This can be one of
                        <literal>NIM</literal> or <literal>TTL</literal></seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>errorflagmask</seg>
                        <seg>Integer 0-0xffff</seg>
                        <seg>0</seg>
                        <seg>Error flag bitmask that determines what lights
                        the front panel error LED given specific error
                        conditions</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>errorflagdatamask</seg>
                        <seg>Integer  0-0xffff</seg>
                        <seg>0</seg>
                        <seg>Error flag bitmask that determines which which error
                        conditions result in an error condition in the event.</seg>
                    </seglistitem>
                    </segmentedlist>
                    
                </section>
                <section>
                    <title>Internal Logic block parameters</title>
                    <para>
                        Triggers can be the result of sophisiticated conditions in
                        two internal logic blocks called ITLA and ITLB.
                        This set of parameters determine how those  logic blocks
                        function.  Because there are two logic blocks, These
                        parameters are  mostly in pairs, on parameter for ITLA
                        and a second for ITLB
                    </para>
                    <segmentedlist>
                        <title>
                        </title>
                    <segtitle>Name</segtitle>
                    <segtitle>Data type</segtitle>
                    <segtitle>Default</segtitle>
                    <segtitle>Description</segtitle>
                    <seglistitem>
                        <seg>itlalogic, itlblogic</seg>
                        <seg>Enumerated value</seg>
                        <seg>OR, OR</seg>
                        <seg>
                            Determines how the channel inputs to the
                            ITLA/ITLB logic blocks are interpreted to
                            create a trigger output from that block.
                            Options are:
                            <literal>
                              OR, AND, Majority
                            </literal>
                            Note that if <literal>Majority</literal>  is selected,
                            <literal>itlxmarjoritylevel</literal> determines the
                            actual majoriy level required.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlamajoritylevel, itlbmajoritylevel</seg>
                        <seg>Integeer 1-63</seg>
                        <seg>1</seg>
                        <seg>The majority level for the specified trigger
                        gropu.  Note this is only relevant if the corresponding
                        trigger block is functioning in <literal>Majority</literal>
                        mode.</seg>
                        
                    </seglistitem>
                    <seglistitem>
                        <seg>itlapairlogic, itlbparilogic</seg>
                        <seg>Enumerated value</seg>
                        <seg>None, None</seg>
                        <seg>
                            Adjacent channel pairs (0,1 2,3 etc.) can be combined
                            as inputs to the ITLA or ITLB logic blocks. These
                            parameters determine if and how those pairs are combined.
                            When combined, both outputs of the pair will be the
                            ouptput of the logic function applied (e.g. if in AND
                            mode and only channel 0 triggers, then both inputs 0 and 1
                            will be in the untriggered state as inputs to the logic block).
                            Possible values are:
                            <literal>
                                AND, OR, NONE
                            </literal>  Where <literal>AND</literal> as well as
                            <literal>OR</literal> combine the inputs into a paired
                            while <literal>NONE</literal> passes the inputs to their
                            corresonding outputs without any pair logic.
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlapolarity, itlbpolarity</seg>
                        <seg>Enumerated value</seg>
                        <seg>Direct, Direct</seg>
                        <seg>Determines the output polarity of the specified
                        trigger logic block.
                        This can be either <literal>Direct</literal>
                        or <literal>Inverted</literal>
                        </seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlamask, itlbmask</seg>
                        <seg>Integer 0 - 0xffffffffffffffff</seg>
                        <seg>0xffffffffffffffff, 0xffffffffffffffff</seg>
                        <seg>This mask has a bit for each channel, if set that channel
                        participates in the associated internal trigger logic block.</seg>
                    </seglistitem>
                    <seglistitem>
                        <seg>itlagatewidth, itlbgatewidth</seg>
                        <seg>Integer nanoseconds 0-524280</seg>
                        <seg>100, 100</seg>
                        <seg>The ITLA and ITLB outputs are inputs to gate generators.
                        These parameters determine the width of the output of that
                        gate generator in ns.</seg>
                    </seglistitem>
                    </segmentedlist>
                    
                </section>
                <section>
                    <title>LVDS Options</title>
                    <para>
                        The 16 LVDS I/Os can be programmed in a sets of four (quartets).
                        The parameters in this section describe how to configure them.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>lvdsmode</seg>
                            <seg>List of 4 enumerated values</seg>
                            <seg>[lrepeat IORegister 4]</seg>
                            <seg>
                                Determines the functionality of each of the four
                                quartets of LVDS I/Os:
                                <literal>SelfTriggers, Sync, IORegister</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdsdirection</seg>
                            <seg>List of four enumerate valus</seg>
                            <seg>[lrepeat Output 4]</seg>
                            <seg>Determines the direction of each of the four
                            quartests of LVDS I/Os: <literal>Input, Output</literal></seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdstrgmask</seg>
                            <seg>List of 16 integer values 0 - 0xffffffffffffffff</seg>
                            <seg>[lrepeate 0 16]</seg>
                            <seg>If a quartet is in <literal>SelfTriggers</literal>
                            mode as an <literal>Output</literal>, these masks
                            determine which self triggers are associated with each pin
                            of the LVDS output in that quartet.  There are 16 elements
                            corresponding to each of the 16 LVDS I/O pins. If
                            a pin is not in a quartet that is configured as
                            a <literal>SelfTriggers</literal> <literal>Output</literal>
                            it's mask is ignored.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>lvdsoutput</seg>
                            <seg>Integer 0-0xffff</seg>
                            <seg>0</seg>
                            <seg>
                                If a pin is part of a quartet that's configured for
                                <literal>IORegister</literal>, <literal>Output</literal>,
                                The corresponding bit of this mask determines the
                                value of that pin.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>DAC  options</title>
                    <para>
                        Each module has a dedicated Digital to Analog Converter
                        (DAC).  The <literal>DAC</literal> LEMO output on the
                        module front panel reflects the output of this device.
                        These parameters control what that is.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>dacoutmode</seg>
                            <seg>Enumerated Value</seg>
                            <seg>ChSum</seg>
                            <seg>Determines what the input to the DAC is.
                            Legal values are
                            <literal>
                                Static, IPE, ChInput, MemOccupancy, ChSum, OverThrSum,
                                Ramp, Sin5MHz, Square
                            </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dacoutputlevel</seg>
                            <seg>Integer 0-16383</seg>
                            <seg>0</seg>
                            <seg>
                                If the output mode is <literal>Static</literal>,
                                the output is the DAC conversion of this value
                                as its input.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dacoutchannel</seg>
                            <seg>integer 0-63</seg>
                            <seg>0</seg>
                            <seg>If the DAC output mode is
                            <literal>ChInput</literal> this value selects the
                            channel input that is echoed on the DAC output.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>Input conditioning</title>
                    <para>
                        Describes the parameters that control the relationship
                        between the raw ADC inputs and what the digitizers see.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>vgagain</seg>
                            <seg>List of four integers 0-40</seg>
                            <seg>0</seg>
                            <seg>If the module is equipped with variable gain
                            amplifiers on its input, each amplifier gain is common
                            between 16 inputs.  This list of parameters sets the
                            VGA Gain for groups of 16 channels.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>offsetcalibrationenable</seg>
                            <seg>Boolean value</seg>
                            <seg>true</seg>
                            <seg>Enable/disable the offset calibraion for each channel.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>channelenables</seg>
                            <seg>List of 64 booleans</seg>
                            <seg>[lrepeat true 64]</seg>
                            <seg>
                                For each channel when its corresponding list element
                                is true, the channel is enabled, otherwise it is
                                disabled.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>dcoffsets</seg>
                            <seg>List of 64 floats 0-100.0</seg>
                            <seg>[lrepeat 50.0 64]</seg>
                            <seg>For each channel, this is the DC Offset applied
                            to the channels.</seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>triggerthresholds</seg>
                            <seg>64 element list of integers 0-8191</seg>
                            <seg>1023</seg>
                            <seg>
                                Channel trigger thresholds.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>inputpolarities</seg>
                            <seg>list of 64 enums</seg>
                            <seg>[lrepeat Negative 64]</seg>
                            <seg>Sets the polarity of the input pulse for each channel.
                            Valid values are <literal>Positive</literal>
                            and <literal>Negative</literal></seg>
                        </seglistitem>
                    </segmentedlist>
                                           
                </section>
                <section>
                    <title>Event Selection Options</title>
                    <para>
                        The module has several post trigger event filtering options
                        that can be set.  These options are exposed as:
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>energyskimlow</seg>
                            <seg>64 element integer list 0-65534</seg>
                            <seg>[lrepeat 0 64]</seg>
                            <seg>
                                Events in a channel with computed energies
                                less than this value (for that channel) are not
                                passed to the host.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>energyskimhigh</seg>
                            <seg>64 element integer list 0-65534</seg>
                            <seg>[lrepeat 65534 64]</seg>
                            <seg>
                                Events in a channel with computed energies
                                higher than this value (for that channel) are not
                                passed to the host. Thus the <literal>energyskimlow</literal>
                                and <literal>energyfilterhigh</literal> values
                                for each channel provide an energy cut between
                                which events are accepted and outside of which
                                they are rejected.  See, however
                                <literal>eventselector</literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>eventselector</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat All 64</seg>
                            <seg>
                                Selects which events (energy values) are
                                saved for each channel. Valid values for each
                                element of the list are
                                <literal>All, Pileup, EnergySkim</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>waveselector</seg>
                           <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat All 64</seg>
                            <seg>
                                Selects which waveforms are
                                saved for each channel. Valid values for each
                                element of the list are
                                <literal>All, Pileup, EnergySkim</literal>.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>coincidencemask</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeat Disabled 64]</seg>
                            <seg>
                                Defines a concidence source for a trigger on each
                                channel.  Valid values are:
                                <literal>
                                    Disabled, Ch64Trigger, TRGIN,
                                    GlobalTriggerSource, ITLA, ITLB
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>anticoincidencemask</seg>
                            <seg>List of 64 enumerated values</seg>
                            <seg>[lrepeate Disabled 64</seg>
                            <seg>
                                Defines an anticoincidence source for a trigger
                                on each channel.  Valid values are:
                                <literal>
                                    Disabled, Ch64Trigger, TRGIN,
                                    GlobalTriggerSource, ITLA, ITLB
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>coincidencelength</seg>
                            <seg>List of 64 integer values in nanoseconds 8-524280</seg>
                            <seg>[lrepeat 100 64</seg>
                            <seg>
                                Defines, for each channel, the coincidence window
                                in nanoseconds for the coincidence and anti
                                coincidence trigger sources defined by
                                <literal>coincidencemask</literal>
                                and <literal>anticoincidencemask</literal>.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
                <section>
                    <title>DPP Processing parameters</title>
                    <para>
                        Firmware on the module processes raw, digitized wave forms
                        into pulse heights (energies).  This processing includes a
                        time filter and an energy filter.  The parameters
                        in this section are relevant to those two filters.
                    </para>
                    <para>
                        Figure 3  of the <literal>FELib PHA Parameters User Manual</literal>
                        is a useful description of these parameters and how they
                        drive signal processing.
                    </para>
                    <segmentedlist>
                        <title></title>
                        <segtitle>Name</segtitle>
                        <segtitle>Data type</segtitle>
                        <segtitle>Default</segtitle>
                        <segtitle>Description</segtitle>
                        <seglistitem>
                            <seg>tfrisetime</seg>
                            <seg>64 element list of integers 4-250</seg>
                            <seg>[lrepeate 80 64]</seg>
                            <seg>
                                The rise time parameter for the time
                                fiter for each channel
                                expressed in digitizer samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>tfretriggerguard</seg>
                            <seg>64 element list of integers 0-1000</seg>
                            <seg>[lrepeat 0 64]</seg>
                            <seg>
                                The time filter retrigger guard for each
                                channel expressed in samples. 
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efrisetime</seg>
                            <seg>64 element list of integers 4-1625</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                The rise time parameter of the enegy filter
                                for each channel expressed in samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efflattoptime</seg>
                            <seg>64 element list of integers 4-375</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                The energy filter flattop time parameter
                                in units of samples for each channel.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpeakingpos</seg>
                            <seg>64 element list of integers 10-90</seg>
                            <seg>[lrepeat 50 64]</seg>
                            <seg>
                                The trapezoid peaking position for each channel
                                in percentage of the flattop time.  Note the
                                manual, at the time I'm writing this erroneously
                                expresses the limis on this parameter
                                at 0-100. 
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpeakingavg</seg>
                            <seg>list of 64 enumerated values</seg>
                            <seg>[lrepeat 1 64]</seg>
                            <seg>
                                Number of samples averaged to evaluate the
                                peak for each channel.  Legal values are
                                <literal>
                                    1, 4, 16, 64
                                </literal>
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpolezero</seg>
                            <seg>list of 64 integers 4-65500</seg>
                            <seg>[lrepeat 80 64]</seg>
                            <seg>
                                Pole zero adjustment of the digital shaping
                                amplifier for each channel in units of samples.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>effinegain</seg>
                            <seg>list of 64 floating point values 1.0-10.0</seg>
                            <seg>[lrepeat 1.0 64]</seg>
                            <seg>
                                Sets the digital fine gain for each channel.
                                The granularity of these values is
                                0.001.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>eflflimitation</seg>
                            <seg>64 element list of bools</seg>
                            <seg>[lrepeat false 64]</seg>
                            <seg>
                                When enabled for a channel, a low frequency
                                filter is applied to that channel for the
                                energy filter.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efbaselineavg</seg>
                            <seg>64 element list of enumerated values</seg>
                            <seg>[lrepeat 16 64]</seg>
                            <seg>
                                The number of samples averaged to compute the
                                signal baseline prior to the start of the
                                trapezoidal filter.  Legal values for each
                                element are:
                                <literal>0, 16, 64, 256, 1024, 4096, 16384</literal>.
                                Note that a value of <literal>0</literal>
                                fixes the baseline at zero.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efbaselineguardt</seg>
                            <seg>list of 64 integer values. 0-8000</seg>
                            <seg>[lrepeat 0 64]</seg>
                            <seg>
                                The time, for each channel, after the trapezoidal
                                filter before basline computation will resume.
                                These values are in units of nanoseconds.
                            </seg>
                        </seglistitem>
                        <seglistitem>
                            <seg>efpileupguardt</seg>
                            <seg>List of 64 integers 0-8000</seg>
                            <seg>[lrepeat 0 64</seg>
                            <seg>
                                For each channel, specifies, in ns, the guard time
                                that defines energy filter pileup.
                            </seg>
                        </seglistitem>
                    </segmentedlist>
                </section>
            </section>
        </section>
        <section id='sec.eventstruct'>
            <title id='sec.eventstruct.title'></title>
            <para>
                This section describes events written by the Readout program.
                These hits are encapsulated in NSCLDAQ ringitems.  When the event
                builder is  in use, additional event builder encapsulation
                will occur.
            </para>
            <para>
                Ring items are described in the NSCLDAQ documentation.
                This is in the form of an annotated header for
                <filename>DataFormat.h</filename>.  See e.g.
                <ulink url="https://docs.nscl.msu.edu/daq/newsite/nscldaq-11.3/r22906.html" />.
                In order to support event building, the ring items that encapslate
                hits include a body header.  The body header includes the hit timestamp
                and sourceid as well as a zero valued barrier type.
            </para>
            <para>
                The additional event builder encapsulation is described in the
                NSCLDAQ section on the event builder e.g.
                <ulink url='https://docs.nscl.msu.edu/daq/newsite/nscldaq-11.3/x4509.html' />
            </para>
            <para>
                This leaves to us documenting the format of the body of a hit:
            </para>
            <table>
                <title>Format of event body</title>
                <tgroup cols='2' align='left' colsep='1' rowsep='1'>
                    <colspec colname='type' />
                    <colspec colname='what' />
                    <thead>
                        <row>
                            <entry>Data Type</entry>
                            <entry>Contents</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of uint16_t's in the event</entry>
                        </row>
                        <row>
                            <entry>Variable.</entry>
                            <entry>Null terminated string that identifies the module</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Channel within the module the hit came from</entry>
                        </row>
                        <row>
                            <entry>uint64_t</entry>
                            <entry>Hit timestamp in nanoseconds</entry>
                        </row>
                        <row>
                            <entry>uint64_t</entry>
                            <entry>raw timestamp only meaningful if selected</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>fine timestamp only meaningful if selected</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Peak height (energy)</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Low priority flags. Only meaningful if selected.</entry>
                        </row>
                        <row>
                            <entry>uint16_t></entry>
                            <entry>High priority flags. Only meaningful if selected.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Down sample selection code. Only meaningful if selected</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>
                                Fail flags.  Only meaningful if selected</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Analog probe type 1 - only meaningful if
                            analog probe 1 is selected for readout</entry>
                        </row>
                        <row>
                            <entry>
                                uint32_t
                            </entry>
                            <entry>Number of samples of analog probe 1 data.
                            This is zero if analog probe 1 is not selecte.</entry>
                        </row>
                        <row>
                            <entry>variable number of uint32_t values</entry>
                            <entry>Analog probe 1 values.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Analog probe type 2 - only meaningful if
                            analog probe 2 is selected for readout</entry>
                        </row>
                        <row>
                            <entry>
                                uint32_t
                            </entry>
                            <entry>Number of samples of analog probe 1 data.
                            This is zero if analog probe 2 is not selected.</entry>
                        </row>
                        <row>
                            <entry>variable number of uint32_t values</entry>
                            <entry>Analog probe 1 values.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Digital probe type 1 - only meaningful if digital probe 1 is selected
                            </entry>
                        </row>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of samples in digital probe 1</entry>
                        </row>
                        <row>
                            <entry>variable number of uint8_ts</entry>
                            <entry>Digital probe sample.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Digital probe type 2 - only meaningful if digital probe 2 is selected
                            </entry>
                        </row>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of samples in digital probe 2</entry>
                        </row>
                        <row>
                            <entry>variable number of uint8_ts</entry>
                            <entry>Digital probe sample.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Digital probe type 3 - only meaningful if digital probe 3 is selected
                            </entry>
                        </row>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of samples in digital probe 3</entry>
                        </row>
                        <row>
                            <entry>variable number of uint8_ts</entry>
                            <entry>Digital probe sample.</entry>
                        </row>
                        <row>
                            <entry>uint16_t</entry>
                            <entry>Digital probe type 4 - only meaningful if digital probe 4 is selected
                            </entry>
                        </row>
                        <row>
                            <entry>uint32_t</entry>
                            <entry>Number of samples in digital probe 4</entry>
                        </row>
                        <row>
                            <entry>variable number of uint8_ts</entry>
                            <entry>Digital probe sample.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
                Note that if needed an additional byte will pad out the end of the
                event to bring it to an even number of <type>uint16_t</type>.
                However, since there are an even number of digital probes,
                all with the same length, I don't think this padding ever happens.
            </para>
        </section>
    </chapter>
    <chapter id='ch.spectcl'>
        <title id='ch.spectcl.title'>
            Configuring SpecTcl
        </title>
        <para>
            Some classes have been written to make the unpacking of raw parameters
            from hits within an event built event simple.
            With SpecTcl's event processing pipeline architecture, once raw
            events have been unpacked into parameters and accessible data structures,
            it is simple to add additional event processors to the pipeline
            to perform arbitrary computations.
        </para>
        <para>
            This chapter will describe:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  The support classes you need to know to unpack digitizer data. 
               </para>
            </listitem>
            <listitem>
               <para>
                  How to obtain a copy of the SpecTcl Skeleton you will modify
                  to create a version of SpecTcl capable of analyzing the event
                  built data.
               </para>
            </listitem>
            <listitem>
               <para>
                  How to modify the Makefile so that the classes written to
                  unpack data from the digitizers can be incorporated intothe built
                  SpecTcl.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            SpecTcl documentation is available in
            <ulink url='http://docs.nscl.msu.edu/daq' />.
            I recommend using a release of SpecTcl version 5.12.  This version
            has the infrastructure to unpack event built data needed by
            the classes we'll use, as well as the new QtPi displayer as an option
            if you want capabilities beyond those offered by <literal>Xamine</literal>.
        </para>
        <para>
            Note that a complete example is provided in the <filename>tclreadout/SpecTcl</filename>
            subdirectory of the source tree.
            <filename></filename>
        </para>
        <section>
            <title>Unpacking classes</title>
            <para>
                The <filename>libCaenVxUnpackers.a</filename> library provides
                classes that understand how to unpack data from the
                event built data for the CAEN Digitizers.  This section
                describes those classes.
            </para>
            <para>
                The two main classes you will need are
                <classname>VX2750ModuleUnpacker</classname> and
                <classname>VX2750EventBuiltEventProcessor</classname>.
            </para>
            <para>
                <classname>VX2750ModuleUnpacker </classname> is responsible
                for unpacking hits from a module into a set of
                parameters and internal data.  Energies, and timestamps, for
                example are unpacked into SpecTcl parameters and can be directly
                histogrammed.  Analog and digital probe data, however cannot and
                are loaded into internal data where event processors later in the
                pipeline can fetch them, if needed, to produce parameters or,
                in the case of traces, load them on demend into spectra, so they
                can be visualized.
            </para>
            <para>
                A class that you normally won't need to directly instantiate,
                <classname>VX2750EventProcessor</classname> is responsible
                for ensure that module unpackers are called with
                a pointer to data for a hit.  The event processor is also
                responsible for informing the unpacker when event processing begins
                and, therefore, internal data can be cleared.
            </para>
            <para>
                Separate sections will describe the methods you will need
                to interact with both the unpacker and the event built event
                processor.
            </para>
            <section>
                <title>The <classname>VX2750ModuleUnpacker</classname> class</title>
                <para>
                    Given a pointer to the data from a module,
                    <classname>VX2750ModuleUnpacker</classname> instances
                    <methodname>unpackHit</methodname> method cumulatively
                    unpacks hits into SpecTcl parameters and internal data until
                    the <methodname>reset</methodname> is invoked.  Normally
                    <methodname>reset</methodname> if invoked by framing code
                    as processing of a new event begins.
                </para>
                <para>
                    Methods provide access to internal data for subsequent
                    stages of SpecTcl's event processing pipeline.
                    Here are the important methods of
                    <classname>VX2750ModuleUnpacker</classname>.
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>VX2750ModuleUnpacker</methodname>
                           <methodparam>
                               <type>const char*</type><parameter>moduleName</parameter>
                           </methodparam>
                           <methodparam>
                               <type>const char*</type><parameter>paramBaseName</parameter>
                           </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                                Constructs a new instance.  <parameter>moduleName</parameter>
                                is the name of the module that will be unpacked.
                                Attempting to pass data for another module to
                                <methodname>unpackHit</methodname>
                                will result in an exception.
                                The <parameter>paramBaseName</parameter> parameter
                                provides the base parameter name of the SpecTcl
                                parameters this object will produce.
                           </para>
                           <para>
                                The unpacker, when called for each hit in an event,
                                will produce parameter arrays for the timestamp
                                in nanoseconds, the raw timestamp and the fine timestamp
                                as well as the energy.  Suppose, that
                                A hit is constructed with a parameter base value
                                of <literal>someModule</literal>;  construction
                                will build Tree Parameter arrays, containing 64
                                elements (one for each channel), that are named
                                <literal>someModule.ns</literal>,
                                <literal>someModule.rawTime</literal>,
                                <literal>someModule.fineTime</literal> and
                                <literal>someModule.energy</literal>.
                           </para>
                           <para>
                            Note that only elements for which hits have been
                            seen will have valid values and that SpecTcl will not
                            histogram parameters that don't have valid values.
                            Furthermore, with the exception of the nanosecond time and
                            energy, the readout must have enabled readout of the other
                            parameters for those to have meaningful values.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void</type>
                          <methodname>reset</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Called to reset all of the internal data. Note that
                            SpecTcl's begin event processing invalidates the
                            tree parameter arrays in O(1) time so these are not
                            touched by <methodname>reset</methodname>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const void*</type>
                          <methodname>unpackHit</methodname>
                          <methodparam>
                              <type>const void*</type><parameter>pData</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Processes data from a hit cumulatively into the
                            Tree parameter arrays and internal data.
                            Returns a pointer to the byte just after the hit.
                            If the data does not point to a hit from the
                            correct module a <classname>std::logic_error</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint64_t </type>
                          <methodname>getChannelMask</methodname>
                          <void />
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a bitmask of the channels that have been
                            passed to <methodname>unpackHit</methodname>
                            since the last call to <methodname>reset</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::set&lt;unsigned&gt;</type>
                          <methodname>getChannelSet</methodname>
                          <void />
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as <methodname>?getChannelMask</methodname>
                            but the returned value is a set containing the
                            numbers of all channesl that have been processed.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t </type>
                          <methodname>getLowPriorityFlags</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>channel</parameter>
                              <modifier> const</modifier>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Gets the low priority flag value for channel
                            <parameter>channel</parameter>.  If the channel
                            has had a hit since the last <methodname>reset</methodname>,
                            or if the channel value is out of range,
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                           <para>
                            Note that if the low priority flags
                            were not selected to be read out, this value is
                            meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t </type>
                          <methodname>getHighPriorityFlags</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>channel</parameter>
                              <modifier> const</modifier>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Gets the high priority flag value for channel
                            <parameter>channel</parameter>.  If the channel
                            has had a hit since the last <methodname>reset</methodname>,
                            or if the channel value is out of range,
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                           <para>
                            Note that if the low priority flags
                            were not selected to be read out, this value is
                            meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t </type>
                          <methodname>getDownSampleSelection</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>channel</parameter>
                              <modifier> const</modifier>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Gets down sampling code for 
                            <parameter>channel</parameter>.  If the channel
                            has had a hit since the last <methodname>reset</methodname>,
                            or if the channel value is out of range,
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                           <para>
                            Note that if the down sampling code
                            was not selected to be read out, this value is
                            meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getFailFlags</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the fail flag bit mask for <parameter>channel</parameter>.
                            If the event does not have a hit from
                            <parameter>channel</parameter>, or <parameter>channel</parameter>
                            is out of range, <classname>std::invalid_argument</classname>
                            is thrown.  Note that if you have not enabled error
                            flags in the event readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getAnalogProbe1Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the type code for analog probe 1.
                            Note that if analog probe 1 is not enabled for the
                            event readout, this will be a meaningless value.
                            If <parameter>channel</parameter> is not present
                            in the event or out of range;
                            <classname>std::invalid_argument</classname>
                            will be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint32_t&gt;&amp;</type>
                          <methodname>getAnalogProbe1Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples from analog probe 1.  If
                            analog probe 1 is not enabled for readout, this will
                            reference a zero length vector.  If the
                            <parameter>channel</parameter> is out of range or has not
                            provided a hit to this event,
                            <classname>std::invalid_argument</classname> will
                            be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                                        <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getAnalogProbe2Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the type code for analog probe 2.
                            Note that if analog probe 2 is not enabled for the
                            event readout, this will be a meaningless value.
                            If <parameter>channel</parameter> is not present
                            in the event or out of range;
                            <classname>std::invalid_argument</classname>
                            will be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint32_t&gt;&amp;</type>
                          <methodname>getAnalogProbe2Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples from analog probe 2.  If
                            analog probe 2 is not enabled for readout, this will
                            reference a zero length vector.  If the
                            <parameter>channel</parameter> is out of range or has not
                            provided a hit to this event,
                            <classname>std::invalid_argument</classname> will
                            be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getDigitalProbe1Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Get the probe type code for digital probe 1.
                            If <parameter>channel</parameter> is not present
                            or out of range <classname>std::invalid_argument</classname>
                            is thrown.  Note that if digital probe 1 is not
                            enabled for readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint8_t&gt;&amp;</type>
                          <methodname>getDigitalProbe1Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples for digital probe 1.  If
                            digital probe 1 is not enabled for readout, this
                            will be a reference to a zero length vector.
                            If <parameter>channel</parameter> is out of range
                            or not present in the event
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getDigitalProbe2Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Get the probe type code for digital probe 2.
                            If <parameter>channel</parameter> is not present
                            or out of range <classname>std::invalid_argument</classname>
                            is thrown.  Note that if digital probe 2 is not
                            enabled for readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint8_t&gt;&amp;</type>
                          <methodname>getDigitalProbe2Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples for digital probe 2.  If
                            digital probe 2 is not enabled for readout, this
                            will be a reference to a zero length vector.
                            If <parameter>channel</parameter> is out of range
                            or not present in the event
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getDigitalProbe3Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Get the probe type code for digitial probe 3.
                            If <parameter>channel</parameter> is not present
                            or out of range <classname>std::invalid_argument</classname>
                            is thrown.  Note that if digital probe 3 is not
                            enabled for readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint8_t&gt;&amp;</type>
                          <methodname>getDigitalProbe4Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples for digital probe 4.  If
                            digital probe 4 is not enabled for readout, this
                            will be a reference to a zero length vector.
                            If <parameter>channel</parameter> is out of range
                            or not present in the event
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>std::uint16_t</type>
                          <methodname>getDigitalProbe1Type</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Get the probe type code for digitial probe 1.
                            If <parameter>channel</parameter> is not present
                            or out of range <classname>std::invalid_argument</classname>
                            is thrown.  Note that if digital probe 1 is not
                            enabled for readout, this value will be meaningless.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const std::vector&lt;std::uint8_t&gt;&amp;</type>
                          <methodname>getDigitalProbe1Samples</methodname>
                          <methodparam>
                              <type>unsigned</type><parameter>channel</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the samples for digital probe 1.  If
                            digital probe 1 is not enabled for readout, this
                            will be a reference to a zero length vector.
                            If <parameter>channel</parameter> is out of range
                            or not present in the event
                            <classname>std::invalid_argument</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
            <section>
                <title>The <classname>VX2750EvenBuiltEventProcessor</classname> class</title>
                <para>
                    Normally, you will not need to call
                    <classname>VX2750ModuleUnpacker</classname>::<methodname>unpackHit</methodname>
                    directly.  Since you will normally attach SpecTcl to the
                    output of the event builder, you will instantiate
                    <classname>VX2750ModuleUnpacker</classname> objects and register
                    them with an instance of the
                    <classname>VX2750EventBuiltEventProcessor</classname>.
                </para>
                <para>
                    The <classname>VX2750EventBuiltEventProcessor</classname>
                    understands the fragment wrapping of the event builder output.
                    It processes event built events and dispatches to event
                    processors that are registered to handle specific
                    source ids (in this case modules).
                </para>
                <para>
                    Usually you will:
                </para>
                <orderedlist>
                    <listitem>
                       <para>
                          Construct a <classname>VX2750EventBuiltEventProcessor</classname>.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          For each module, associated a module name with
                          a source id and provide a base parameter name
                          from which all of the parameters it provides
                          will be constructed.
                       </para>
                    </listitem>
                    
                    <listitem>
                       <para>
                          Register your
                          <classname>VX2750EventBuiltEventProcessor</classname>
                          with SpecTcl's event processing pipeline so that it
                          will gain control for each event.
                       </para>
                    </listitem>
                </orderedlist>
                <para>
                    Here are the signatures of the method in
                    <classname>VX2750EventBuiltEventProcessor</classname>
                    you'll need to use:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> VX2750EventBuiltEventProcessor</methodname>
                        
                           <methodparam>
                               <type>std::string</type><parameter>baseName</parameter>
                           </methodparam>
                            
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                              Constructor.  The <parameter>baseName</parameter>
                              provides the base name for parameters that can be
                              used for clock/synchronization diagnostics.
                              The class is derived from the
                              <classname>CEventBuilderEventProcessor</classname>.
                              The diagnoistic parameters produced are
                              described in
                              <ulink url='https://docs.nscl.msu.edu/daq/newsite/spectcl-5.0/pgmref/r8783.html' />
                              in the SpecTcl programming reference manual.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void </type>
                          <methodname>addEventProcessor</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const std::string&amp; </type><parameter>moduleName</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const std::string </type><parameter>paramBasename</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                               This method constructs a
                               <classname>VX2750ModuleUnpacker</classname>
                               for the module <parameter>moduleName</parameter>.
                               The resulting object is then wrapped in a
                               <classname>VX2750EventProcessor</classname>
                               which will poduce parameters with a base name
                               <parameter>paramBasename</parameter>
                           </para>
                           <para>
                            The event processor will be registered to
                            handle fragments from <parameter>sourceId</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void </type>
                          <methodname>addEventProcessor</methodname>
                          <methodparam>
                              <type>unsigned </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>VX2750ModuleUnpacker&amp;</type><parameter>unpacker</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            The prior overload is the simplest way to register
                            a module with the SpecTcl unpacking framwork.
                            Using it, however, loses access to the additional
                            data that is unpacked for each event that is not
                            put in a SpecTcl parameter (e.g. the analog probes).
                           </para>
                           <para>
                            This method, takes a constructed module unpacker,
                            wraps it in an event processor that will produce
                            parameters using the module name as the parameter base name.
                            The resulting event processor is then registered to
                            handle data from <parameter>sourceID</parameter>.
                           </para>
                           <para>
                            Using this allows you to retain the event unpacker
                            object for use in a later event processor.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>
        <section>
            <title>Obtaining and modifying the skeleton</title>
            <para>
                In this and subsequent sections we assume that your SpecTcl
                installation top level directory is pointed to by an environment
                variable <literal>SPECTCLHOME</literal>.  This is simply a convenience
                to make it simpler to describe the actions you need to take.
            </para>
            <para>
                To obtain a copy of the SpecTcl skeleton for your viersion:
            </para>
            <example>
                <title>Obtaining a copy of the SpecTcl skeleton</title>
                <programlisting>
mkdir myspectcl
cp -R $SPECTCLHOME/Skel/* .

                </programlisting>
            </example>
            <para>
                This should provide a number of files, many of which are used
                to extend the QtPy display program, if desired (see e.g.
                <ulink url='https://docs.nscl.msu.edu/daq/newsite/qtpy/index.html'/>).
                The files we'll need to play with to tailor SpecTcl to handle our
                data are:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      <filename>MySpecTclApp.cpp</filename>; a skeletal application
                      class in whose methods SpecTcl extensions and customizations
                      are done.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      <filename>Makefile</filename>.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                This section will show how to modify the <filename>MySpecTclApp.cpp</filename>
                file and the next will show modifications needed to the
                <filename>Makefile</filename> to pull in headers and libraries
                needed to support the modifications we've made.
            </para>
            <para>
                Here is a <filename>MySpecTclApp.cpp</filename> modified to
                analyze data from a single module.  The discussion following
                this example will describe how to extend this to a system
                with additional modules.  The full example is in the
                <filename>tclreadout/SpecTcl</filename> subdirectory of the
                source tree.
            </para>
            <example>
                <title><filename>MySpecTclApp.cpp</filename> modified for a single module</title>
                <programlisting>

#include &lt;VX2750EventBuiltEventProcessor.h&gt;   <co id='spectclapp.includes' />
#include &lt;VX2750ModuleUnpacker.h&gt;

...


void
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)  <co id='spectclapp.pipeline' />
{

    auto pTopLevel = new                                        <co id='spectclapp.builtproc' />
      caen_spectcl::VX2750EventBuiltEventProcessor("diagnostic");
      
    auto pAdc1 =                                                 <co id='spectclapp.module' />
        new caen_spectcl::VX2750ModuleUnpacker("adc1", "adc1-params");      
    pTopLevel-&gt;addEventProcessor(1, *pAdc1);                   <co id='spectclapp.regmodule' />
    
    RegisterEventProcessor(*pTopLevel, "Raw");                    <co id='spectclapp.regprocessor' />
}


                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='spectclapp.includes' >
                    <para>
                        <filename>MySpecTclApp.cpp</filename>
                        must incorporate the class definitions for the
                        <classname>VX2750EventBuiltEventProcessor</classname>
                        and the
                        <classname>VX2750ModuleUnpacker</classname>.  These headers
                        will also spur some of our
                        <filename>Makefile</filename> modifications.
                    </para>
                </callout>
                <callout arearefs='spectclapp.pipeline' >
                    <para>
                        In most cases, <classname>MySpecTclApp.cpp</classname>
                        only needs to be modified to describe the
                        <firstterm>Event analysis pipeline</firstterm>
                        used for an application.  The event analysis
                        pipeline is described in detail in
                        the SpecTcl programming guide:
                        <ulink url='https://docs.nscl.msu.edu/daq/newsite/spectcl-5.0/pgmguide/index.html' />.
                    </para>
                    <para>
                        To summarize, however, the event processing pipeline is
                        a logical sequence, pipeline, that takes as input, raw
                        event data and produces as output parameters that SpecTcl's
                        histogramming engine uses to increment spectra defined by
                        the user.  Each stage of the pipeline has available, not
                        only the raw event, but the parameters and data
                        produced by prior elements of the pipeline.
                    </para>
                    <para>
                        Elements of the event processing pipeline are called,
                        unoriginally enough, <firstterm>Event Processors</firstterm>
                        and are all derived, ultimately, from the
                        <classname>CEventProcessor</classname> class.
                        In <methodname>CreateAnalysisPipeline</methodname>,
                        <filename>MySpecTclApp.cpp</filename> is modified to
                        define event processors and the order in which they
                        execute for each event.
                    </para>
                    <para>
                        SpecTcl-5.0 supports dynamic event processing pipelines
                        (composing pipelines from either compiled in event processors
                        or event processors dynamically loaded from whared libraries
                        at run time.)  This is beyond the scope of this document
                        and is described in chapter 12 of the
                        programming guide.
                    </para>
                </callout>
                <callout arearefs='spectclapp.builtproc' >
                    <para>
                        This line creates a
                        <classname>VX2750EventBuiltEventProcessor</classname>.
                        As previously descdribed, this event processor knows
                        how to dig event fragments from a built event and
                        pass them on to processors registered for each
                        source id.  It also maintains diagnostic parameters
                        that allow you to monitor the synchronization of
                        the clocks in each event source.
                    </para>
                    <para>
                        Recall that in this application, each module is an
                        event source with its own  unique source id.
                    </para>
                </callout>
                <callout arearefs='spectclapp.module' >
                    <para>
                        A module unpacker knows how to unpack the data from a
                        single module.  It is normally wrapped in a
                        <classname>VX2750EventProcessor</classname> object
                        which, given a pointer to the data for a fragment,
                        computes the pointer to the raw data for the module
                        and passes that to the module unpacker it wraps.
                    </para>
                    <para>
                        In this line we create a <classname>VX2750ModuleUnpacker</classname>
                        for the <literal>adc1</literal> module (the name
                        must match the module name used in the readout program),
                        and specify that parameters produced by this unpacker
                        will be given names that start with
                        <literal>adc1-params.</literal>.
                    </para>
                    <para>
                        If you wanted to perform processing on data this
                        module unpacks but does not put in parameters, you
                        could take the pointer to the unpacker and pass it
                        to another event processor put in the pipeline
                        after the raw parameter unpacking.
                    </para>
                    
                </callout>
                <callout arearefs='spectclapp.regmodule' >
                    <para>
                        Registers the unpacker we created to handle data from
                        source id <literal>1</literal>.  This too must match
                        the source id specified for this module in the
                        Readout program.
                    </para>
                    <para>
                        In a system with more than one digitizer simply instantiate
                        a module unpacker for each digitizer and register each one
                        to process data from the source id associated with its data.
                    </para>
                </callout>
                <callout arearefs='spectclapp.regprocessor' >
                    <para>
                        Appends the event built event processor to the event
                        processing pipeline.  If you have additional processing
                        stages you would create event processors for each stage
                        and register them in the order in which they will be
                        called.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Building the tailored SpecTcl</title>
            <para>
                The <filename>Makefile</filename> in the skeleton is
                a starting point from which a tailored Makefile can be made.
                In the case of the <filename>MySpecTclApp.cpp</filename>
                we tailored in the previous section, we must:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      Specify the location of the additional header files
                      that are required.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Specify the location and name of the additional library
                      we need to pull the classes into our SpecTcl.
                      
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                The next example shows these modifications.  We assume that
                the support software has been installed in
              <filename>/usr/opt/lbnl</filename>
            </para>
            <example>
                <title>
                    Makefile for SpecTcl
                </title>
                <programlisting>
INSTDIR=/usr/opt/spectcl/5.12-008

CAEN_ROOT=/usr/opt/lbnl                      <co id='spmake.base' />

# Skeleton makefile for 3.1

include $(INSTDIR)/etc/SpecTcl_Makefile.include

#  If you have any switches that need to be added to the default c++ compilation
# rules, add them to the definition below:

USERCXXFLAGS=-I$(CAEN_ROOT)/include      <co id='spmake.includes' />

#  If you have any switches you need to add to the default c compilation rules,
#  add them to the defintion below:

USERCCFLAGS=$(USERCXXFLAGS)

#  If you have any switches you need to add to the link add them below:

USERLDFLAGS=-L$(CAEN_ROOT)/lib -lCaenVxUnpackers  <co id='spmake.libs' />
#
#   Append your objects to the definitions below:
#

OBJECTS=MySpecTclApp.o

#
#  Finally the makefile targets.
#


SpecTcl: $(OBJECTS)
        $(CXXLD)  -o SpecTcl $(OBJECTS) $(USERLDFLAGS) \
        $(LDFLAGS)


clean:
        rm -f $(OBJECTS) SpecTcl

                </programlisting>
            </example>
            <para>
                The SpecTcl skeleton Makefile provides three variables that,
                in many cases, are all that need to be modified to
                tailor the <filename>Makefile</filename>:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      <literal>USERCXXFLAGS</literal>  provides additional
                      compilations flags to the C/C++ compiler used by the
                      default compilation rules.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      <literal>USELDFLAGS</literal>, similarly, provide additional
                      flags passed to the link step of the SpecTcl Build.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      <literal>OBJECTS</literal> is a list of objects that must
                      be built for SpecTcl to be tailored.  without additional
                      rules, a file specified in <literal>OBJECTS</literal> will
                      be built from sources using the default compilation rules
                      SpecTcl's Makefile establishes.  IF these cannot be made to
                      work by setting <literal>USERCXXFLAGS</literal>, the user
                      may certainly supply explicit compilation rules.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                In our example, we don't introduce any additional compiled object.
                So:
            </para>
            <calloutlist>
                <callout arearefs='spmake.base' >
                    <para>
                        In order to make our definitions easy to change, we first
                        define the Makefile varaible <literal>CAEN_ROOT</literal>
                        to be the top level of the directory in which we
                        installed the CAEN support software.
                    </para>
                </callout>
                <callout arearefs='spmake.includes' >
                    <para>
                        Defines <literal>USERCXXFLAGS</literal>, the additional
                        compilation flags we need to include the
                        <filename>include</filename> directory of the
                        header search path for the compilers.
                    </para>
                </callout>
                <callout arearefs='spmake.libs' >
                    <para>
                        Defines <literal>USERLDFLAGS</literal>, the additional
                        link flags we need to add the CAEN unpacker library directory
                        to the library search path and explicity requests
                        that
                        <filename>libCaenVxUnpackers.a</filename> be searched
                        to satisfy external references.
                    </para>
                    <para>
                        If the library ever becomes a shared object we'd need
                        to add <literal>-Wl,-rpath=$(CAEN_ROOT)/lib</literal>
                        to the <literal>USERLDFLAGS</literal>.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </chapter>
    <appendix id='app.internals'>
        <title>Software structure</title>
        <para>
            This documentation of the software internals separates into two
            mostly independent chunks.  Support for Readout and support for
            SpecTcl.
        </para>
        <para>
            In all cases a layered approach was taken.  This provides a realtively
            easy to use system which may not perform at the fastest possible speed,
            but can later be optimized either by using the lower layers of software
            directly or by transparently optimizing some of the lower layers for
            the upper layers.
        </para>
        <section>
            <title>Readout Software</title>
            <para>
                The software described in this section is in
                <filename>libCaenVx2750.a</filename>
            </para>
            <para>
                The CAEN support for the VXxxxx digitizers with DPP-PHA firmware
                is supplied as ilbraries that are installed either on the host
                system or in the container image.  This support consists of two
                libraries.  The first communicates with the digitizer and the
                second provides a filesystem like image of the digitizer parameter
                space.
            </para>
            <para>
                On problem with the CAEN library support is that since parameters
                are file system path-like names and values are strings, errors
                can only be detected at run-time.  Two classes have been layered on
                top of the bas CAEN support, in the <literal>caen_nscldaq</literal>
                namespace:
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>Dig2Device</classname></term>
                   <listitem>
                       <para>
                        Provides basic communication support.  This class establishes
                        communication with boards and provides separated access
                        to the chunks of the digitizer filesystem that provide
                        parameters for different levels of acces.
                       </para>
                       <para>
                        For example, there are methods that write/read digitizer
                        level parameters, and methods that write/read channel level
                        parameters.  Similarly some methods control the LVDS I/Os
                        on the front panel, while others provide support to configure
                        the module for readout and to read individual events from
                        the module.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>VX2750Pha</classname></term>
                   <listitem>
                       <para>
                        This provides enumerated contants and methods which
                        provide access to teach of the parameters in the digitizer.
                        Note that since this is derived from <classname>Dig2Device</classname>,
                        should CAEN introduce additional parameters, they can be
                        directly accessed via the methds of that class until
                        appropriate methods are added to
                        <classname>VX2750Pha</classname>.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                There are a large number of parameters that can/must be
                configured to get the digitizer to do what you want it to do.
                The configuration for a single module is captured in a
                <classname>VX2750PHAConfiguration</classname> object.
                This object is agnostic about how it is configured.
                Support for creating and manipulating configurations using the
                Tcl scripting language is provided by
                <classname>VX2750TclConfig</classname>.
            </para>
            <para>
                Initially I wanted to be able to configure the modules using
                the same XML file produced by the COMPASS program and there
                is initial, untested code in <classname>VX2750XMLConfig</classname>
                to do that.  However the XML definition is not described anywhere and
                there are specific, important parameters I don't understand how
                to extract from that file.  The specification for the XML file is
                internal to the COMPASS group and, at least for the prior generation
                of digitizers, has changed from version to version leaving a
                full implementation of <classname>VX27850XMLConfig</classname>
                vulnerable to COMPASS updates.
            </para>
            <para>
                The Readout framework chosen requires a custom trigger and
                readout code.  The trigge tells the framework when it is appropriate
                to invoke the readout code.  The framework takes care of packaging the
                data read into ringitems an putting them into ringbufers where they
                can serve as input to the event builder.
            </para>
            <para>
                The classes at this level of the code are:
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>VX2750EventSegment</classname></term>
                   <listitem>
                       <para>
                        Knows how to read data when it is available in a single
                        module.  This uses a configuration object to initialize the
                        modules.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CAENVX2750PhaTrigger</classname></term>
                   <listitem>
                       <para>
                        Knows how to determine if a single module has
                        data.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Since, in general, a system consists of several modules,
                The following classes are containers which support multi-module
                setups.
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>VX2750MultiTrigger</classname></term>
                   <listitem>
                       <para>
                        Contains several indivdual module trigger objects.  In a single
                         poll, makes available thet set of readable modules.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>VX2750MultiModuleEventSegment</classname></term>
                   <listitem>
                       <para>
                        Contains several individual module event segments and
                        creates a multi trigger from them.  When called, it will
                        invoke the read methods of all of the event segments in
                        each module that has data.
                       </para>
                       <para>
                        This latter is done in a way the the event in each module
                        is treated as a single ring item.  The Readout framework
                        has a mechanism for a reader to specify that, upon providing
                        data it can read more data without the need to poll the trigger.
                        This mechanism is used by
                        <classname>VX2750MultiModuleEventSegment</classname>.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>SpecTcl Support</title>
            <para>
                SpecTcl support requires, at a minimum, some user code that can
                unpack raw data (in this case from the event builder) into
                a set of parameters.  These parameters are then fed to SpecTcl's
                histograming engine which, using spectrum definitions gates and
                gates applied to spectra maintains histograms.  The classes described
                in this section are in <filename>libCaenVxUnpackers</filename>.
            </para>
            <para>
                Histograms can be dynamically created as can gates snd the application
                of those gates to conditionalize spectrum increments.  
            </para>
            <para>
                SpecTcl accomplishes this mapping of raw event data to parameters
                via a programmatic scheme called the <firstterm>Data Analysis Pipeline</firstterm>.
                As the name implies the pipeline is made up of stages.  Each stage
                of the pipeline has access, not only to the raw event data, but the
                parameters that have been been produced by prior stages of the pipeline.
            </para>
            <para>
                While the DPP-PHA firmware has relatively few parameters that can
                be unpacked directly from its data (time and pulse height), depending
                on the items selected for readout, it can produce data that may be
                useful to other stage of the pipeline.  F
            </para>
            <para>
                For example, you can select to read the waveforms that were inputs
                to the DPP-PHA algorithm as well as some of the intermediate data.
                Computations could be done on these traces or a spectrum could be
                set-aside to be used to display waveforms on demand.
            </para>
            <para>
                The SpecTcl support provides software that knows how to unpack
                an event fragment or <firstterm>hit</firstterm> from a digitizer.
                It also provides framing software that is cognizant of event boundaries
                and calls appropriate unpacking software for each module throughout the
                hits the event builder has determined constitute an event.
            </para>
            <para>
                The relavent classes are:
            </para>
            <variablelist>
                <varlistentry>
                   <term><classname>VX2750ModuleUnpacker</classname></term>
                   <listitem>
                       <para>
                        Given a pointer to raw hit data unpacks the data from
                        the hit.  This class produces four  parameters for each
                        channel that's hit:  The nanosecond time, the raw time
                        the fine timestamp and the energy.
                       </para>
                       <para>
                        In addition to these parameters, internal data is maintained
                        for all other information the digitizer can produce.
                        <firstterm>Getter</firstterm> methods allow access
                        to these data.  You can imagine that in creating one or more
                        module unpackers, you might store pointers or references
                        to them in downstream elements of the analysis pipeline where
                        additional information could be extracted.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>VX2750EventProcessor</classname></term>
                   <listitem>
                       <para>
                        An event processor which, given a pointer to the body of
                        an event fragment invokes an unpacker to unpack data from
                        that hit.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>VX2750EventBuiltEventProcessor</classname></term>
                   <listitem>
                       <para>
                            This event processor holds a collection of
                            <classname>VX2750EventProcessor</classname> objects.
                            It accepts the body of an event from the event builder
                            and iterates over the fragments.  For each fragment,
                            the fragment's source id is used to select a
                            <classname>VX2750EventProcessor</classname> to use
                            to unpack the data in that fragment.
                       </para>
                       <para>
                        THe source id, in the readout scheme represents a module.
                        It is possible for an event to have more thano n e hit from
                        a module...in which case the module's unpacker is called
                        more than once per event.  Presumably this fill in data from
                        several channels in the module.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>To Do:</title>
            <para>
                If possible, with a bit of close cooperation from the CAEN
                Compass team, I'd like to revisit the possibility of configuring
                the system from a COMPASS XML file.
            </para>
            <para>
                Initializing a module takes too much time (my opinion).  This is
                done at the beginning of each run. I can see two improvements
                in this process:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Do a full initialization only on start up and scoreboard
                      changes to the configuration, only programming those at the
                      beginning of a run.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Support multichannel settings.   The CAEN parameter
                      'filesystem' provides a method to set several channel
                      level parameters to same value in a single transaction.
                      Supporting this <emphasis>could</emphasis> reduce the
                      number of device transactions needed for a full initialization.
                   </para>
                </listitem>
                
            </orderedlist>
        </section>
    </appendix>
    <appendix>
        <title>Class reference</title>
        <para>
            This appendix provides class reference material for the classes
            that make up both the NSCLDAQ and SpecTcl support.
            The two sections of man pages are
            <literal>3daq</literal> which cover classes that make up the
            DAQ support and <literal>3spectcl</literal> which provides reference
            material for SpecTcl class support.
        </para>
        <section>
            <title>NSLCDAQ Support (3daq)</title>
            <refentry>
               <refmeta>
                  <refentrytitle>caen_nscldaq::Dig2Device</refentrytitle>
                  <manvolnum>3daq</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>caen_nscldaq::Dig2Device</refname>
                  <refpurpose>Low Level Access To Digitizers</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;Dig2Device.h&gt;
namespace caen_nscldaq {
    void set_tracing(bool onoff) ;
    
    class Dig2Device {
    private:
        std::uint64_t m_deviceHandle;
        std::uint64_t m_endpointHandle;
    public:
        Dig2Device(const char* hostOrPid, bool isUsb = false);
        virtual ~Dig2Device();
        
        
        void SetValue(const char* parameterName, const char* value) const;
        void SetValue(const char* parameterName, int  value) const;
        void SetValue(const char* parameterName, std::uint64_t value) const;
        void SetValue(const char* parameterName, double value) const;
        void SetValue(const char* parameterName, bool value) const;

        
        void SetDeviceValue(const char* devParName, const char* value) const;
        void SetDeviceValue(const char* devParName, int value) const;
        void SetDeviceValue(const char* devParName, std::uint64_t value) const;
        void SetDeviceValue(const char* devParName, double value) const;
        void SetDeviceValue(const char* devParName, bool value) const;

        
        void SetChanValue(unsigned chan, const char* chanParName, const char* value) const;
        void SetChanValue(unsigned chan, const char* chanParName, int value) const;
        void SetChanValue(unsigned chan, const char* chanParName, std::uint64_t value) const;
        void SetChanValue(unsigned chan, const char* chanParName, double value) const;
        void SetChanValue(unsigned chan, const char* chanParName, bool value) const;

        
        void SetLVDSValue(unsigned quartet, const char* LVDSName, const char* value) const;
        void SetLVDSValue(unsigned quartet, const char* LVDSName, int value) const;
        void SetLVDSValue(unsigned quartet, const char* LVDSName, std::uint64_t value) const;
        void SetLVDSTriggerMask(unsigned maskNo, std::uint64_t mask) const;
        
        std::string GetValue(const char* parameterName, const char* initial = nullptr) const;
        int         GetInteger(const char* parameterName) const;
        std::uint64_t GetULong(const char* parameterName) const;
        double      GetReal(const char* parameterName) const;
        bool        GetBool(const char* parameterName) const;

        std::string GetDeviceValue(const char* parameterName) const;
        int         GetDeviceInteger(const char* parameterName) const;
        std::uint64_t GetDeviceULong(const char* parameterName) const;
        double      GetDeviceReal(const char* parameterName) const;
        bool        GetDeviceBool(const char* parameterName) const;
        
        std::string GetChanValue(unsigned chan, const char* parameterName) const;
        int         GetChanInteger(unsigned chan, const char* parameterName) const;
        std::uint64_t GetChanULong(unsigned chan, const char* parameterName) const;
        double      GetChanReal(unsigned chan, const char* parameterName) const;
        bool        GetChanBool(unsigned chan, const char* parameterName) const;
        
        std::string GetLVDSValue(unsigned quartet, const char* parameterName) const;
        int         GetLVDSInteger(unsigned quartet, const char* parameterName) const;
        std::uint64_t GetLVDSULong(unsigned quartet, const char* parameterName) const;
        std::uint64_t GetLVDSTriggerMask(unsigned maskNo) const;
        
        void Command(const char* command) const;
        
        void SetActiveEndpoint(const char* ep) const;
        std::string GetActiveEndpoint() const;
        void SetReadDataFormat(const char* json) const;
                
        bool ReadData(int timeout, int argc, void** argv) const;
        bool hasData() const;
    };
}

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        <classname>Dig2Device</classname> provides low level
                        access to the the device, channel and LVDS parameter spaces
                        of a CAEN nextgen digitizer.  For parameter setting
                        methods, method overloading provides the appearance of
                        a single method, while, since C++ does not support overloading
                        that is based solely on  the return type, there are separate
                        parameter getters for each possible parameter type.
                      </para>
                      <para>
                        Addditionally, digitizer commands, endpoint selection,
                        testing for data presence and data acquisition are
                        supported at a low level.
                      </para>
                      <para>
                        Note that if the class is built with the preprocessor
                        variable <literal>ENABLE_TRACING</literal> defined
                        and <function>caen_nscldaq::set_tracing</function>
                        is called with a <literal>true</literal> parameter,
                        all interactions with the CAEN support library will
                        be logged to the file <filename>Dig2Device.log</filename>.
                        This causes a huge performance hit but is useful
                        in sending information to CAEN support when questions
                        about digitizer operation arise.
                      </para>
                </refsect1>
                <refsect1>
                    <title>
                        METHODS and CONSTRUCTION
                    </title>
                    <variablelist>
                        <varlistentry>
                           <term><constructorsynopsis>
                               <methodname> Dig2Device</methodname>
                                <methodparam>
                                    <type>const char*</type><parameter>hostOrPid</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>bool </type><parameter>isUsb </parameter>
                                    <initializer>false</initializer>
                                </methodparam>
                           </constructorsynopsis></term>
                           <listitem>
                               <para>
                                Constructing a <classname>Dig2Device</classname>
                                requires knowing how to connect to the device.
                                There are currently two ways to do so, direct USB
                                connection of via ETHERNET.  The <parameter>hostOrPid</parameter>
                                parameter should be a textual host (dotted IP address
                                e.g. <literal>"10.0.0.2"</literal>)  or the USB
                                PID of the module (there's a sticker on each module
                                with the module's pid e.g. <literal>"15236"</literal>)
                                depending on how you are connecting to the module.
                               </para>
                               <para>
                                The <parameter>isUsb</parameter> parameter, which
                                defaults to <literal>false</literal> should be
                                <literal>true</literal> only if you are connected
                                directly to the module via USB.
                               </para>
                               <para>
                                Note that no DNS translation is attempted on the
                                <parameter>hostOrPid</parameter> parameter if
                                <parameter>isUsb</parameter> is false.  
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetValue</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <methodparam>
                                  <type> T </type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                This  is the core parameter setting method.
                                <parameter>parameterName</parameter> is a full,
                                absolute path to the parameter being set and
                                <parameter>value</parameter> is the value to
                                set the parameter to.  
                               </para>
                               <para>
                                The
                                <type>T</type> data type for <parameter>value</parameter>,
                                in this case indicates that there are several overloads
                                for this method in which T has the type
                                <type>const char*</type>,
                                <type>int</type>,
                                <type>std::uint64_t</type>,
                                <type>double</type>
                                and <type>bool</type>, for the various data types
                                that parameters may take.
                               </para>
                               <para>
                                    Note that the CAEN API requires stringified
                                    versions when setting all of its parameter types,
                                    so the various overloads eventually invoke
                                    the <methodname>SetValue</methodname>
                                    that accept a <type>const char*</type>
                                    vaule.
                                </para>
                               <para>
                                    Errors reported back by the CAEN FELib
                                    are converted to
                                    <classname>std::runtime_error</classname>
                                    exceptions.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetDeviceValue</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>devParName</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>T</type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The parameter space of the CAEN digitizers looks
                                like a file system.  Paths to parameters look like
                                paths to files in that file system.  The
                                <emphasis>directory</emphasis> parts of that path
                                determine the class of the parameter.
                                Device level parameters have a specific and
                                (mostly) consistent path. 
                               </para>
                               <para>
                                This overloaded method (same possible types for
                                <parameter>value</parameter> as <methodname>SetValue</methodname>)
                                computes the path to a device level paramter given the
                                terminal node in the path and invokes
                                <methodname>SetValue</methodname> to set a device
                                level parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetChanValue</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char*</type><parameter> chanParName</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>T</type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                As with device parameters, per channel parameters
                                have paths that are consistently constructed
                                given the parameter name and channel number.
                                This method computes the full path to a per channel
                                parameter and sets that parameter.  It is overloaded
                                int the same manner as <parameter>SetValue</parameter>.
                               </para>
                               <para>
                                Note that the CAEN FELib API actually supports setting
                                more than one per channel parameter to the same
                                value if the channels involved form a contiguous
                                range.  This is not supported in this version of the
                                class.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetLVDSValue</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>quartet</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>LVDSName</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>T </type><parameter>value</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                The parameters that control the functionality of
                                the front panel LVDS I/O pins is a separate part
                                of the digitizer parameter 'filesystem' parameter
                                space.  This is because the 16 pins are organized into
                                4 pin quartets that can be independently programmed.
                               </para>
                               <para>
                                This overloaded method computes the path
                                to the specified parameter name and quartet and
                                sets that parameter's value.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetLVDSTriggerMask</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>maskNo</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>std::uint64_t </type><parameter>mask</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                With apologies to my colleagues at CAEN>  THe
                                handling of the LVDS trigger mask is just totally
                                inconsistent with the manner in which all other
                                parameters in the digitizer are handled.
                                They therefore merit a separate method to set
                                their values.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                              <methodsynopsis>
                                 <type>std::string </type>
                                 <methodname>GetValue</methodname>
                                 <methodparam>
                                     <type>const char* </type><parameter>parameterName</parameter>
                                 </methodparam>
                                 <methodparam>
                                     <type>const char* </type><parameter>initial</parameter>
                                    <initializer>nullptr</initializer>
                                 </methodparam>
                                 <modifier>const</modifier>
                              </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the raw parameter string for a digitizer
                                parameter given its full path.  The
                                <parameter>initial</parameter> parameter has to do
                                with the wonky manner in which LVDS trigger masks
                                must be set.  Ignore and use
                                <methodname>GetLVDSTriggerMask</methodname> to
                                retrieve those trigger masks and it will take care
                                handling that wonkiness transparently.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int         </type>
                              <methodname>GetInteger</methodname>
                              <methodparam>
                                  <type>const char*</type><parameter> parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Invokes <methodname>GetValue</methodname> and
                                attempts to conver the resulting string to
                                an integer which is then returned.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>GetULong</methodname>
                              <methodparam>
                                  <type>const char*</type><parameter> parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetValue</methodname>, converts
                                the returned string to a <type>std::uint64_t</type>
                                and returns the converted value.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double      </type>
                              <methodname>GetReal</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetValue</methodname> and converts
                                the result to a <type>double</type>
                                which is returned.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool </type>
                              <methodname>GetBool</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetValue</methodname> and
                                converts the returned value to a boolean
                                which is returned.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string </type>
                              <methodname>GetDeviceValue</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Computes the full path to the device level parameter
                                <parameter>parameterName</parameter> and
                                returns
                                the value <methodname>GetValue</methodname>
                                returns for that path.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int         </type>
                              <methodname>GetDeviceInteger</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetDeviceValue</methodname>
                                but calls <methodname>GetInteger</methodname>
                                with the computed full path.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>td::uint64_t </type>
                              <methodname>GetDeviceULong</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier> const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetUlong</methodname> with
                                the computed full path to the parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double      </type>
                              <methodname>GetDeviceReal</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier> const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>GetReal</methodname> with the
                                fully computed path to <parameter>parameterName</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool        </type>
                              <methodname>GetDeviceBool</methodname>
                              <methodparam>
                                  <type>const char*</type><parameter> parameterName</parameter>
                              </methodparam>
                              <modifier>
                                const
                              </modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Calls <methodname>getBool</methodname> with the
                                full computed path for <parameter>parameterName</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string </type>
                              <methodname>GetChanValue</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Computes the full path to
                                the channel level parameter;
                                <parameter>parameterName</parameter> for
                                channel <parameter>chan</parameter> and
                                returns the value for
                                <methodname>getValue</methodname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int         </type>
                              <methodname>GetChanInteger</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>getChanValue</methodname>
                                but returns the value of <methodname>GetInteger</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>GetChanULong</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetChanValue</methodname>
                                but returns the value of <methodname>GetUlong</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>double      </type>
                              <methodname>GetChanReal</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char*</type><parameter> parameterName</parameter>
                              </methodparam>
                              <modifier>
                                const
                              </modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetChanValue</methodname>
                                but returns the result of <methodname>GetReal</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool        </type>
                              <methodname>GetChanBool</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>chan</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as
                                <methodname>GetChanValue</methodname> but returns
                                the results of <methodname>GetBool</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::string </type>
                              <methodname>GetLVDSValue</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>quartet</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Retrieves the value of the LVDS configuration
                                parameter; <parameter>parameterName</parameter>
                                for the selected
                                <parameter>quartet</parameter> of pins.
                                This computes the full path to that parameter
                                and invokes <methodname>GetValue</methodname>
                                to get the result.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>int </type>
                              <methodname>GetLVDSInteger</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>quartet</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetLVDSValue</methodname>
                                but uses <methodname>GetInteger</methodname>
                                to retrive the result.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>GetLVDSUlong</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>quartet</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>const char* </type><parameter>parameterName</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Same as <methodname>GetLVDSValue</methodname>
                                but uses <methodname>GetULong</methodname>
                                to retrive the result.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>std::uint64_t </type>
                              <methodname>GetLVDSTriggerMask</methodname>
                              <methodparam>
                                  <type>unsigned </type><parameter>maskNo</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                See my rather acerbit note about LVS trigger masks
                                in <methodname>SetLVDSTriggerMask</methodname>.
                                This returns the value of LVDS trigger mask
                                <parameter>maskNo</parameter>.  That is the
                                mask to be applied to pin
                                <parameter>maskNo</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>Command</methodname>
                              <methodparam>
                                  <type>const char*</type><parameter> command</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Sends the command specified by
                                <parameter>command</parameter> to the digitizer.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetActiveEndpoint</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>ep</parameter>
                              </methodparam>
                              <modifier> const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Digitizers have several endpoints from which data
                                can be acquired.  In order to acquire data
                                from an endpoint the end point must be made
                                active and its data format configured
                                (see <methodname>SetReadDataFormat</methodname>).
                                Once this is  done, <methodname>hasData</methodname>
                                and <methodname>ReadData</methodname> will,
                                respectively, check for data on the active endpoint
                                and read data from it.
                               </para>
                               <para>
                                The set of endpoints exported by a digitizer
                                depend on the firmware that it is running.
                               </para>
                               <para>
                                This method selects the active endpoint
                                via its name: <parameter>ep</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type> std::string </type>
                              <methodname>GetActiveEndpoint</methodname>
                              <void />
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the name of the currently active
                                digitizer endpoint.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>void </type>
                              <methodname>SetReadDataFormat</methodname>
                              <methodparam>
                                  <type>const char* </type><parameter>json</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Each endpoint can, on a read, return a number of
                                parameters, at the client's discretion.
                                The parameters desired and the order in which
                                they are desired is determined by a JSON
                                (JavaScript Object Notation) string that is passed
                                as <parameter>json</parameter> to  this method.
                               </para>
                               <para>
                                The method determines what is returned by
                                <methodname>ReadData</methodname> for the active
                                endpoint.  It also, implicitly detemrines the
                                number and type of parameters to be passed to
                                <methodname>ReadData</methodname>.
                               </para>
                               <para>
                                The specific set of parameters and each parameter
                                type depends on the firmware running in the digitizer
                                and the current endpoint.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool</type>
                              <methodname>ReadData</methodname>
                              <methodparam>
                                  <type>int</type><parameter>timeout</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>int </type><parameter>argc</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>void** </type><parameter>argv</parameter>
                              </methodparam>
                              <modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Attempts to read data from the active endpoint.
                                If no data is available within
                                <parameter>timeout</parameter> millisconds of
                                initiating the read, the method returns
                                <literal>false</literal>,  If data is available,
                                then the method returns <literal>true</literal>
                               </para>
                               <para>
                                <parameter>argc</parameter> is the number of
                                parameters in the argument array <parameter>argv</parameter>.
                                <parameter>argv</parameter>, in general is an
                                array of pointers to buffers for the items
                                sequentially requested in the JSON passed to
                                <methodname>SetReadDataFormat</methodname>
                                for the active endpoint.  The data types to
                                which the pointers point, again, is determined
                                by the JSON passed to the endpoint.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>bool</type>
                              <methodname>hasData</methodname>
                              <void />
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns <literal>true</literal> if the digitizer
                                has data on the currently selected endpoint
                                or <literal>false</literal> if not.
                                This returns immediately either way.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                
                </refsect1>
            </refentry>
            
        </section>
    </appendix>
</book>